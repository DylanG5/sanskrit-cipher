\documentclass[12pt, titlepage]{article}

\usepackage{fullpage}
\usepackage[round]{natbib}
\usepackage{multirow}
\usepackage{booktabs}
\usepackage{tabularx}
\usepackage{graphicx}
\usepackage{float}
\usepackage{hyperref}
\hypersetup{
    colorlinks,
    citecolor=blue,
    filecolor=black,
    linkcolor=red,
    urlcolor=blue
}

\input{../../Comments}
\input{../../Common}

\newcounter{acnum}
\newcommand{\actheacnum}{AC\theacnum}
\newcommand{\acref}[1]{AC\ref{#1}}

\newcounter{ucnum}
\newcommand{\uctheucnum}{UC\theucnum}
\newcommand{\uref}[1]{UC\ref{#1}}

\newcounter{mnum}
\newcommand{\mthemnum}{M\themnum}
\newcommand{\mref}[1]{M\ref{#1}}

\begin{document}

\title{Module Guide for \progname{}} 
\author{\authname}
\date{\today}

\maketitle

\pagenumbering{roman}

\section{Revision History}

\begin{tabularx}{\textwidth}{p{3cm}p{2cm}X}
\toprule {\bf Date} & {\bf Version} & {\bf Notes}\\
\midrule
Date 1 & 1.0 & Notes\\
Date 2 & 1.1 & Notes\\
\bottomrule
\end{tabularx}

\newpage

\section{Reference Material}

This section records information for easy reference.

\subsection{Abbreviations and Acronyms}

\renewcommand{\arraystretch}{1.2}
\begin{tabular}{l l} 
  \toprule
  \textbf{symbol} & \textbf{description}\\
  \midrule
  AC & Anticipated Change\\
  AI & Artificial Intelligence\\
  API & Application Programming Interface\\
  CNN & Convolutional Neural Network\\
  CV & Computer Vision\\
  DAG & Directed Acyclic Graph \\
  JSON & JavaScript Object Notation\\
  M & Module \\
  MG & Module Guide \\
  ML & Machine Learning\\
  OCR & Optical Character Recognition\\
  OS & Operating System \\
  R & Requirement\\
  SRS & Software Requirements Specification\\
  UI & User Interface\\
  UC & Unlikely Change \\
  \progname & AI-Powered Manuscript Fragment Reconstruction Platform\\
  \bottomrule
\end{tabular}\\

\newpage

\tableofcontents

\listoftables

\listoffigures

\newpage

\pagenumbering{arabic}

\section{Introduction}

Decomposing a system into modules is a commonly accepted approach to developing
software.  A module is a work assignment for a programmer or programming
team~\citep{ParnasEtAl1984}.  We advocate a decomposition
based on the principle of information hiding~\citep{Parnas1972a}.  This
principle supports design for change, because the ``secrets'' that each module
hides represent likely future changes.  Design for change is valuable in SC,
where modifications are frequent, especially during initial development as the
solution space is explored.  

Our design follows the rules layed out by \citet{ParnasEtAl1984}, as follows:
\begin{itemize}
\item System details that are likely to change independently should be the
  secrets of separate modules.
\item Each data structure is implemented in only one module.
\item Any other program that requires information stored in a module's data
  structures must obtain it by calling access programs belonging to that module.
\end{itemize}

After completing the first stage of the design, the Software Requirements
Specification (SRS), the Module Guide (MG) is developed~\citep{ParnasEtAl1984}. The MG
specifies the modular structure of the system and is intended to allow both
designers and maintainers to easily identify the parts of the software.  The
potential readers of this document are as follows:

\begin{itemize}
\item New project members: This document can be a guide for a new project member
  to easily understand the overall structure and quickly find the
  relevant modules they are searching for.
\item Maintainers: The hierarchical structure of the module guide improves the
  maintainers' understanding when they need to make changes to the system. It is
  important for a maintainer to update the relevant sections of the document
  after changes have been made.
\item Designers: Once the module guide has been written, it can be used to
  check for consistency, feasibility, and flexibility. Designers can verify the
  system in various ways, such as consistency among modules, feasibility of the
  decomposition, and flexibility of the design.
\end{itemize}

The rest of the document is organized as follows. Section
\ref{SecChange} lists the anticipated and unlikely changes of the software
requirements. Section \ref{SecMH} summarizes the module decomposition that
was constructed according to the likely changes. Section \ref{SecConnection}
specifies the connections between the software requirements and the
modules. Section \ref{SecMD} gives a detailed description of the
modules. Section \ref{SecTM} includes two traceability matrices. One checks
the completeness of the design against the requirements provided in the SRS. The
other shows the relation between anticipated changes and the modules. Section
\ref{SecUse} describes the use relation between modules.

\section{Anticipated and Unlikely Changes} \label{SecChange}

This section lists possible changes to the system. According to the likeliness
of the change, the possible changes are classified into two
categories. Anticipated changes are listed in Section \ref{SecAchange}, and
unlikely changes are listed in Section \ref{SecUchange}.

\subsection{Anticipated Changes} \label{SecAchange}

Anticipated changes are the source of the information that is to be hidden
inside the modules. Ideally, changing one of the anticipated changes will only
require changing the one module that hides the associated decision. The approach
adapted here is called design for
change.

\begin{description}
\item[\refstepcounter{acnum} \actheacnum \label{acHardware}:] The specific
  hardware on which the software is running.
\item[\refstepcounter{acnum} \actheacnum \label{acInput}:] The format of the
  image input data (file formats, metadata structure).
\item[\refstepcounter{acnum} \actheacnum \label{acAuth}:] The authentication
  and authorization mechanism for different user types.
\item[\refstepcounter{acnum} \actheacnum \label{acUpload}:] The method for
  uploading and storing fragment images.
\item[\refstepcounter{acnum} \actheacnum \label{acSearch}:] The algorithm used
  for searching and filtering fragments.
\item[\refstepcounter{acnum} \actheacnum \label{acEdgeMatch}:] The machine
  learning model used for edge matching detection.
\item[\refstepcounter{acnum} \actheacnum \label{acDamage}:] The algorithm for
  damage pattern analysis.
\item[\refstepcounter{acnum} \actheacnum \label{acScript}:] The method for
  script classification and similarity matching.
\item[\refstepcounter{acnum} \actheacnum \label{acOCR}:] The optical character
  recognition engine used for text extraction.
\item[\refstepcounter{acnum} \actheacnum \label{acTextSim}:] The algorithm for
  text similarity comparison.
\item[\refstepcounter{acnum} \actheacnum \label{acCanvas}:] The user interface
  framework for the interactive canvas.
\item[\refstepcounter{acnum} \actheacnum \label{acFragStore}:] The database
  schema and storage mechanism for fragment data.
\item[\refstepcounter{acnum} \actheacnum \label{acCatalog}:] The structure of
  catalog metadata.
\item[\refstepcounter{acnum} \actheacnum \label{acMatchOrch}:] The orchestration
  logic for combining multiple ML model results.
\item[\refstepcounter{acnum} \actheacnum \label{acSession}:] The session
  management and state persistence mechanism.
\end{description}

\subsection{Unlikely Changes} \label{SecUchange}

The module design should be as general as possible. However, a general system is
more complex. Sometimes this complexity is not necessary. Fixing some design
decisions at the system architecture stage can simplify the software design. If
these decision should later need to be changed, then many parts of the design
will potentially need to be modified. Hence, it is not intended that these
decisions will be changed.

\begin{description}
\item[\refstepcounter{ucnum} \uctheucnum \label{ucIO}:] Input/Output devices
  (Input: Image files via web upload, Output: Screen display and file export).
\item[\refstepcounter{ucnum} \uctheucnum \label{ucWebApp}:] The system will be
  deployed as a web-based application accessible through standard browsers.
\item[\refstepcounter{ucnum} \uctheucnum \label{ucImageProc}:] The system will
  process 2D images of manuscript fragments.
\item[\refstepcounter{ucnum} \uctheucnum \label{ucCollaborate}:] The system will
  support collaborative work through shared projects and annotations.
\item[\refstepcounter{ucnum} \uctheucnum \label{ucMLCore}:] Machine learning will
  be a core component for fragment matching and analysis.
\end{description}

\section{Module Hierarchy} \label{SecMH}

This section provides an overview of the module design. Modules are summarized
in a hierarchy decomposed by secrets in Table \ref{TblMH}. The modules listed
below, which are leaves in the hierarchy tree, are the modules that will
actually be implemented.

\begin{description}
\item [\refstepcounter{mnum} \mthemnum \label{mHH}:] Hardware-Hiding Module
\item [\refstepcounter{mnum} \mthemnum \label{mCanvas}:] UI.Canvas Module
\item [\refstepcounter{mnum} \mthemnum \label{mSearch}:] UI.Search Module
\item [\refstepcounter{mnum} \mthemnum \label{mAuth}:] UI.Auth Module
\item [\refstepcounter{mnum} \mthemnum \label{mUpload}:] UI.Upload Module
\item [\refstepcounter{mnum} \mthemnum \label{mAPI}:] Svc.API Module
\item [\refstepcounter{mnum} \mthemnum \label{mSearchSvc}:] Svc.Search Module
\item [\refstepcounter{mnum} \mthemnum \label{mAuthZ}:] Svc.AuthZ Module
\item [\refstepcounter{mnum} \mthemnum \label{mSession}:] Svc.Session Module
\item [\refstepcounter{mnum} \mthemnum \label{mProcOrch}:] Svc.ProcOrch Module
\item [\refstepcounter{mnum} \mthemnum \label{mMatchOrch}:] Svc.MatchOrch Module
\item [\refstepcounter{mnum} \mthemnum \label{mFragStore}:] Data.FragmentStore Module
\item [\refstepcounter{mnum} \mthemnum \label{mCatalog}:] Data.Catalog Module
\item [\refstepcounter{mnum} \mthemnum \label{mUser}:] Data.User Module
\item [\refstepcounter{mnum} \mthemnum \label{mProject}:] Data.Project Module
\item [\refstepcounter{mnum} \mthemnum \label{mEdgeMatch}:] ML.EdgeMatch Module
\item [\refstepcounter{mnum} \mthemnum \label{mDamage}:] ML.Damage Module
\item [\refstepcounter{mnum} \mthemnum \label{mScriptClass}:] ML.ScriptClass Module
\item [\refstepcounter{mnum} \mthemnum \label{mOCR}:] ML.OCR Module
\item [\refstepcounter{mnum} \mthemnum \label{mTextSim}:] ML.TextSim Module
\item [\refstepcounter{mnum} \mthemnum \label{mError}:] Error Handling Module
\item [\refstepcounter{mnum} \mthemnum \label{mLogging}:] Logging Module
\item [\refstepcounter{mnum} \mthemnum \label{mConfig}:] Configuration Management Module
\item [\refstepcounter{mnum} \mthemnum \label{mTestStubs}:] Test Stubs Module
\end{description}


\begin{table}[h!]
\centering
\begin{tabular}{p{0.3\textwidth} p{0.6\textwidth}}
\toprule
\textbf{Level 1} & \textbf{Level 2}\\
\midrule

{Hardware-Hiding} & Image Storage Interface \\
\midrule

\multirow{15}{0.3\textwidth}{Behaviour-Hiding} & User Interface: UI.Canvas, UI.Search, UI.Auth, UI.Upload\\
& Service Layer: Svc.API, Svc.Search, Svc.AuthZ, Svc.Session,\\
& \quad\quad\quad\quad\quad\quad Svc.ProcOrch, Svc.MatchOrch\\
& Data Management: Data.FragmentStore, Data.Catalog,\\
& \quad\quad\quad\quad\quad\quad Data.User, Data.Project\\
& Machine Learning Modules: ML.EdgeMatch, ML.Damage,\\
& \quad\quad\quad\quad\quad\quad ML.ScriptClass, ML.OCR, ML.TextSim\\
\midrule

\multirow{3}{0.3\textwidth}{Software Decision} & Utility and Support Modules (Error Handling, Logging,\\
& Configuration Management, Test Stubs)\\
\bottomrule

\end{tabular}
\caption{Module Hierarchy}
\label{TblMH}
\end{table}

\section{Connection Between Requirements and Design} \label{SecConnection}

The design of the system is intended to satisfy the requirements developed in
the SRS. In this stage, the system is decomposed into modules. The connection
between requirements and modules is listed in Table~\ref{TblRT}.

\wss{The intention of this section is to document decisions that are made
  ``between'' the requirements and the design.  To satisfy some requirements,
  design decisions need to be made.  Rather than make these decisions implicit,
  they are explicitly recorded here.  For instance, if a program has security
  requirements, a specific design decision may be made to satisfy those
  requirements with a password.}

\section{Module Decomposition} \label{SecMD}

Modules are decomposed according to the principle of ``information hiding''
proposed by \citet{ParnasEtAl1984}. The \emph{Secrets} field in a module
decomposition is a brief statement of the design decision hidden by the
module. The \emph{Services} field specifies \emph{what} the module will do
without documenting \emph{how} to do it. For each module, a suggestion for the
implementing software is given under the \emph{Implemented By} title. If the
entry is \emph{OS}, this means that the module is provided by the operating
system or by standard programming language libraries.  \emph{\progname{}} means the
module will be implemented by the \progname{} software.

Only the leaf modules in the hierarchy have to be implemented. If a dash
(\emph{--}) is shown, this means that the module is not a leaf and will not have
to be implemented.

\subsection{Hardware Hiding Modules (\mref{mHH})}

\begin{description}
\item[Secrets:]The data structure and algorithm used to implement the virtual
  hardware.
\item[Services:]Serves as a virtual hardware used by the rest of the
  system. This module provides the interface between the hardware and the
  software. So, the system can use it to display outputs or to accept inputs.
\item[Implemented By:] OS
\end{description}

\subsection{Behaviour-Hiding Module}

\begin{description}
\item[Secrets:]The contents of the required behaviours.
\item[Services:]Includes programs that provide externally visible behaviour of
  the system as specified in the software requirements specification (SRS)
  documents. This module serves as a communication layer between the
  hardware-hiding module and the software decision module. The programs in this
  module will need to change if there are changes in the SRS.
\item[Implemented By:] --
\end{description}

\subsubsection{UI.Canvas Module (\mref{mCanvas})}

\begin{description}
\item[Secrets:] The implementation of the interactive canvas for fragment manipulation.
\item[Services:] Provides drag-and-drop interface for positioning fragments, zoom and pan controls, visual overlay of match suggestions, and real-time collaboration indicators.
\item[Implemented By:] \progname{}
\item[Type of Module:] Abstract Data Type
\end{description}

\subsubsection{UI.Search Module (\mref{mSearch})}

\begin{description}
\item[Secrets:] The user interface design for search and filtering functionality.
\item[Services:] Provides search interface for fragments by metadata, filters by script type, region, date range, and collection, and displays search results with previews.
\item[Implemented By:] \progname{}
\item[Type of Module:] Abstract Data Type
\end{description}

\subsubsection{UI.Auth Module (\mref{mAuth})}

\begin{description}
\item[Secrets:] The user interface for authentication and user management.
\item[Services:] Provides login/logout interface, user registration, role-based access control UI, and session management display.
\item[Implemented By:] \progname{}
\item[Type of Module:] Abstract Data Type
\end{description}

\subsubsection{UI.Upload Module (\mref{mUpload})}

\begin{description}
\item[Secrets:] The user interface for uploading fragment images and metadata.
\item[Services:] Provides file upload interface with drag-and-drop support, metadata form for fragment description, upload progress indicators, and batch upload capabilities.
\item[Implemented By:] \progname{}
\item[Type of Module:] Abstract Data Type
\end{description}

\subsubsection{Svc.API Module (\mref{mAPI})}

\begin{description}
\item[Secrets:] The RESTful API endpoint definitions and routing logic.
\item[Services:] Exposes HTTP endpoints for all system operations, handles request validation and response formatting, manages API versioning, and implements rate limiting.
\item[Implemented By:] \progname{}
\item[Type of Module:] Library
\end{description}

\subsubsection{Svc.Search Module (\mref{mSearchSvc})}

\begin{description}
\item[Secrets:] The search algorithm and query optimization logic.
\item[Services:] Performs efficient fragment searches across metadata, implements filtering and sorting logic, manages search indexing, and returns ranked results.
\item[Implemented By:] \progname{}
\item[Type of Module:] Abstract Object
\end{description}

\subsubsection{Svc.AuthZ Module (\mref{mAuthZ})}

\begin{description}
\item[Secrets:] The authentication and authorization implementation.
\item[Services:] Verifies user credentials, manages JWT tokens, enforces role-based permissions, and handles password encryption.
\item[Implemented By:] \progname{}
\item[Type of Module:] Abstract Object
\end{description}

\subsubsection{Svc.Session Module (\mref{mSession})}

\begin{description}
\item[Secrets:] The session state management and persistence mechanism.
\item[Services:] Maintains user session data, handles workspace state persistence, manages collaborative session synchronization, and implements session timeout logic.
\item[Implemented By:] \progname{}
\item[Type of Module:] Abstract Data Type
\end{description}

\subsubsection{Svc.ProcOrch Module (\mref{mProcOrch})}

\begin{description}
\item[Secrets:] The orchestration logic for image processing pipelines.
\item[Services:] Coordinates preprocessing of uploaded images, manages job queues for ML tasks, handles asynchronous processing workflows, and aggregates processing results.
\item[Implemented By:] \progname{}
\item[Type of Module:] Abstract Object
\end{description}

\subsubsection{Svc.MatchOrch Module (\mref{mMatchOrch})}

\begin{description}
\item[Secrets:] The algorithm for combining results from multiple ML models.
\item[Services:] Aggregates match scores from different ML modules, applies weighting to different match criteria, ranks fragment match suggestions, and provides confidence scores.
\item[Implemented By:] \progname{}
\item[Type of Module:] Abstract Object
\end{description}

\subsubsection{Data.FragmentStore Module (\mref{mFragStore})}

\begin{description}
\item[Secrets:] The database schema and queries for fragment storage.
\item[Services:] Stores fragment images and metadata, provides CRUD operations for fragments, manages fragment relationships and matches, and handles versioning of fragment data.
\item[Implemented By:] \progname{}
\item[Type of Module:] Abstract Data Type
\end{description}

\subsubsection{Data.Catalog Module (\mref{mCatalog})}

\begin{description}
\item[Secrets:] The catalog metadata structure and taxonomy.
\item[Services:] Maintains standardized metadata schemas, manages controlled vocabularies (scripts, regions, periods), provides catalog browsing capabilities, and handles metadata validation.
\item[Implemented By:] \progname{}
\item[Type of Module:] Abstract Data Type
\end{description}

\subsubsection{Data.User Module (\mref{mUser})}

\begin{description}
\item[Secrets:] The user data model and storage.
\item[Services:] Stores user profiles and credentials, manages user preferences and settings, tracks user activity and annotations, and handles user role assignments.
\item[Implemented By:] \progname{}
\item[Type of Module:] Abstract Data Type
\end{description}

\subsubsection{Data.Project Module (\mref{mProject})}

\begin{description}
\item[Secrets:] The project data structure for collaborative work.
\item[Services:] Manages project workspaces and collections, stores project-specific fragment groupings, handles collaborative annotations and notes, and tracks project history and changes.
\item[Implemented By:] \progname{}
\item[Type of Module:] Abstract Data Type
\end{description}

\subsubsection{ML.EdgeMatch Module (\mref{mEdgeMatch})}

\begin{description}
\item[Secrets:] The machine learning model for edge matching.
\item[Services:] Detects and analyzes fragment edges, compares edge profiles between fragments, calculates edge match confidence scores, and handles irregular fragment shapes.
\item[Implemented By:] \progname{}
\item[Type of Module:] Abstract Object
\end{description}

\subsubsection{ML.Damage Module (\mref{mDamage})}

\begin{description}
\item[Secrets:] The algorithm for damage pattern analysis.
\item[Services:] Identifies damage patterns (tears, stains, wear), compares damage patterns across fragments, generates damage pattern signatures, and calculates pattern similarity scores.
\item[Implemented By:] \progname{}
\item[Type of Module:] Abstract Object
\end{description}

\subsubsection{ML.ScriptClass Module (\mref{mScriptClass})}

\begin{description}
\item[Secrets:] The script classification model and training data.
\item[Services:] Classifies scripts into predefined categories, analyzes script characteristics and style, compares script similarities between fragments, and provides classification confidence scores.
\item[Implemented By:] \progname{}
\item[Type of Module:] Abstract Object
\end{description}

\subsubsection{ML.OCR Module (\mref{mOCR})}

\begin{description}
\item[Secrets:] The optical character recognition engine configuration.
\item[Services:] Extracts text from fragment images, handles multiple script types and fonts, provides character-level and word-level recognition, and generates confidence scores for recognized text.
\item[Implemented By:] \progname{} (using third-party OCR libraries)
\item[Type of Module:] Abstract Object
\end{description}

\subsubsection{ML.TextSim Module (\mref{mTextSim})}

\begin{description}
\item[Secrets:] The text similarity comparison algorithm.
\item[Services:] Compares extracted text between fragments, identifies potential text continuations, handles partial and damaged text, and calculates text similarity scores.
\item[Implemented By:] \progname{}
\item[Type of Module:] Abstract Object
\end{description}


\subsection{Software Decision Module}

\begin{description}
\item[Secrets:] The design decision based on mathematical theorems, physical
  facts, or programming considerations. The secrets of this module are
  \emph{not} described in the SRS.
\item[Services:] Includes data structure and algorithms used in the system that
  do not provide direct interaction with the user.
  % Changes in these modules are more likely to be motivated by a desire to
  % improve performance than by externally imposed changes.
\item[Implemented By:] --
\end{description}

\subsubsection{Error Handling Module (\mref{mError})}

\begin{description}
\item[Secrets:] The error handling and exception management strategy.
\item[Services:] Provides centralized error handling, formats error messages for users and logs, implements retry logic for transient failures, and manages graceful degradation.
\item[Implemented By:] \progname{}
\item[Type of Module:] Library
\end{description}

\subsubsection{Logging Module (\mref{mLogging})}

\begin{description}
\item[Secrets:] The logging implementation and log format structure.
\item[Services:] Records system events and user actions, implements different log levels (debug, info, warning, error), manages log rotation and archival, and provides log querying capabilities.
\item[Implemented By:] \progname{} (using standard logging libraries)
\item[Type of Module:] Library
\end{description}

\subsubsection{Configuration Management Module (\mref{mConfig})}

\begin{description}
\item[Secrets:] The configuration file format and loading mechanism.
\item[Services:] Loads application configuration from files and environment variables, validates configuration parameters, provides configuration access to other modules, and supports configuration hot-reloading.
\item[Implemented By:] \progname{}
\item[Type of Module:] Abstract Object
\end{description}

\subsubsection{Test Stubs Module (\mref{mTestStubs})}

\begin{description}
\item[Secrets:] The mock implementations for testing purposes.
\item[Services:] Provides stub implementations of external services, generates test data for fragments and metadata, simulates ML model responses, and enables isolated module testing.
\item[Implemented By:] \progname{}
\item[Type of Module:] Library
\end{description}

\section{Traceability Matrix} \label{SecTM}

This section shows two traceability matrices: between the modules and the
requirements and between the modules and the anticipated changes.

% the table should use mref, the requirements should be named, use something
% like fref
\begin{table}[H]
\centering
\begin{tabular}{p{0.2\textwidth} p{0.6\textwidth}}
\toprule
\textbf{Req.} & \textbf{Modules}\\
\midrule
R1 & \mref{mHH}, \mref{mInput}, \mref{mParams}, \mref{mControl}\\
R2 & \mref{mInput}, \mref{mParams}\\
R3 & \mref{mVerify}\\
R4 & \mref{mOutput}, \mref{mControl}\\
R5 & \mref{mOutput}, \mref{mODEs}, \mref{mControl}, \mref{mSeqDS}, \mref{mSolver}, \mref{mPlot}\\
R6 & \mref{mOutput}, \mref{mODEs}, \mref{mControl}, \mref{mSeqDS}, \mref{mSolver}, \mref{mPlot}\\
R7 & \mref{mOutput}, \mref{mEnergy}, \mref{mControl}, \mref{mSeqDS}, \mref{mPlot}\\
R8 & \mref{mOutput}, \mref{mEnergy}, \mref{mControl}, \mref{mSeqDS}, \mref{mPlot}\\
R9 & \mref{mVerifyOut}\\
R10 & \mref{mOutput}, \mref{mODEs}, \mref{mControl}\\
R11 & \mref{mOutput}, \mref{mODEs}, \mref{mEnergy}, \mref{mControl}\\
\bottomrule
\end{tabular}
\caption{Trace Between Requirements and Modules}
\label{TblRT}
\end{table}

\begin{table}[H]
\centering
\begin{tabular}{p{0.2\textwidth} p{0.6\textwidth}}
\toprule
\textbf{AC} & \textbf{Modules}\\
\midrule
\acref{acHardware} & \mref{mHH}\\
\acref{acInput} & \mref{mInput}\\
\acref{acParams} & \mref{mParams}\\
\acref{acVerify} & \mref{mVerify}\\
\acref{acOutput} & \mref{mOutput}\\
\acref{acVerifyOut} & \mref{mVerifyOut}\\
\acref{acODEs} & \mref{mODEs}\\
\acref{acEnergy} & \mref{mEnergy}\\
\acref{acControl} & \mref{mControl}\\
\acref{acSeqDS} & \mref{mSeqDS}\\
\acref{acSolver} & \mref{mSolver}\\
\acref{acPlot} & \mref{mPlot}\\
\bottomrule
\end{tabular}
\caption{Trace Between Anticipated Changes and Modules}
\label{TblACT}
\end{table}

\section{Use Hierarchy Between Modules} \label{SecUse}

In this section, the uses hierarchy between modules is
provided. \citet{Parnas1978} said of two programs A and B that A {\em uses} B if
correct execution of B may be necessary for A to complete the task described in
its specification. That is, A {\em uses} B if there exist situations in which
the correct functioning of A depends upon the availability of a correct
implementation of B.  Figure \ref{FigUH} illustrates the use relation between
the modules. It can be seen that the graph is a directed acyclic graph
(DAG). Each level of the hierarchy offers a testable and usable subset of the
system, and modules in the higher level of the hierarchy are essentially simpler
because they use modules from the lower levels.

\wss{The uses relation is not a data flow diagram.  In the code there will often
be an import statement in module A when it directly uses module B.  Module B
provides the services that module A needs.  The code for module A needs to be
able to see these services (hence the import statement).  Since the uses
relation is transitive, there is a use relation without an import, but the
arrows in the diagram typically correspond to the presence of import statement.}

\wss{If module A uses module B, the arrow is directed from A to B.}

\begin{figure}[H]
\centering
%\includegraphics[width=0.7\textwidth]{UsesHierarchy.png}
\caption{Use hierarchy among modules}
\label{FigUH}
\end{figure}

%\section*{References}

\section{User Interfaces}

\wss{Design of user interface for software and hardware.  Attach an appendix if
needed. Drawings, Sketches, Figma}

\section{Design of Communication Protocols}

\wss{If appropriate}

\section{Timeline}

\wss{Schedule of tasks and who is responsible}

\wss{You can point to GitHub if this information is included there}

\bibliographystyle {plainnat}
\bibliography{../../../refs/References}

\newpage{}

\end{document}