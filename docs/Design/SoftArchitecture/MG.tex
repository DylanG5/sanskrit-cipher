\documentclass[12pt, titlepage]{article}

\usepackage{fullpage}
\usepackage[round]{natbib}
\usepackage{multirow}
\usepackage{booktabs}
\usepackage{tabularx}
\usepackage{graphicx}
\usepackage{float}
\usepackage{hyperref}
\hypersetup{
    colorlinks,
    citecolor=blue,
    filecolor=black,
    linkcolor=red,
    urlcolor=blue
}

\input{../../Comments}
\input{../../Common}

\newcounter{acnum}
\newcommand{\actheacnum}{AC\theacnum}
\newcommand{\acref}[1]{AC\ref{#1}}

\newcounter{ucnum}
\newcommand{\uctheucnum}{UC\theucnum}
\newcommand{\uref}[1]{UC\ref{#1}}

\newcounter{mnum}
\newcommand{\mthemnum}{M\themnum}
\newcommand{\mref}[1]{M\ref{#1}}

\begin{document}

\title{Module Guide for \progname{}} 
\author{\authname}
\date{\today}

\maketitle

\pagenumbering{roman}

\section{Revision History}

\begin{tabularx}{\textwidth}{p{3cm}p{2cm}X}
\toprule {\bf Date} & {\bf Version} & {\bf Notes}\\
\midrule
Date 1 & 1.0 & Notes\\
Date 2 & 1.1 & Notes\\
\bottomrule
\end{tabularx}

\newpage

\section{Reference Material}

This section records information for easy reference.

\subsection{Abbreviations and Acronyms}

\renewcommand{\arraystretch}{1.2}
\begin{tabular}{l l} 
  \toprule
  \textbf{symbol} & \textbf{description}\\
  \midrule
  AC & Anticipated Change\\
  AI & Artificial Intelligence\\
  API & Application Programming Interface\\
  CNN & Convolutional Neural Network\\
  CV & Computer Vision\\
  DAG & Directed Acyclic Graph \\
  JSON & JavaScript Object Notation\\
  M & Module \\
  MG & Module Guide \\
  ML & Machine Learning\\
  OCR & Optical Character Recognition\\
  OS & Operating System \\
  R & Requirement\\
  SRS & Software Requirements Specification\\
  UI & User Interface\\
  UC & Unlikely Change \\
  \bottomrule
\end{tabular}\\

\newpage

\tableofcontents

\listoftables

\listoffigures

\newpage

\pagenumbering{arabic}

\section{Introduction}

Decomposing a system into modules is a commonly accepted approach to developing
software.  A module is a work assignment for a programmer or programming
team~\citep{ParnasEtAl1984}.  We advocate a decomposition
based on the principle of information hiding~\citep{Parnas1972a}.  This
principle supports design for change, because the ``secrets'' that each module
hides represent likely future changes.  Design for change is valuable in SC,
where modifications are frequent, especially during initial development as the
solution space is explored.  

Our design follows the rules layed out by \citet{ParnasEtAl1984}, as follows:
\begin{itemize}
\item System details that are likely to change independently should be the
  secrets of separate modules.
\item Each data structure is implemented in only one module.
\item Any other program that requires information stored in a module's data
  structures must obtain it by calling access programs belonging to that module.
\end{itemize}

After completing the first stage of the design, the Software Requirements
Specification (SRS), the Module Guide (MG) is developed~\citep{ParnasEtAl1984}. The MG
specifies the modular structure of the system and is intended to allow both
designers and maintainers to easily identify the parts of the software.  The
potential readers of this document are as follows:

\begin{itemize}
\item New project members: This document can be a guide for a new project member
  to easily understand the overall structure and quickly find the
  relevant modules they are searching for.
\item Maintainers: The hierarchical structure of the module guide improves the
  maintainers' understanding when they need to make changes to the system. It is
  important for a maintainer to update the relevant sections of the document
  after changes have been made.
\item Designers: Once the module guide has been written, it can be used to
  check for consistency, feasibility, and flexibility. Designers can verify the
  system in various ways, such as consistency among modules, feasibility of the
  decomposition, and flexibility of the design.
\end{itemize}

The rest of the document is organized as follows. Section
\ref{SecChange} lists the anticipated and unlikely changes of the software
requirements. Section \ref{SecMH} summarizes the module decomposition that
was constructed according to the likely changes. Section \ref{SecConnection}
specifies the connections between the software requirements and the
modules. Section \ref{SecMD} gives a detailed description of the
modules. Section \ref{SecTM} includes two traceability matrices. One checks
the completeness of the design against the requirements provided in the SRS. The
other shows the relation between anticipated changes and the modules. Section
\ref{SecUse} describes the use relation between modules.

\section{Anticipated and Unlikely Changes} \label{SecChange}

This section lists possible changes to the system. According to the likeliness
of the change, the possible changes are classified into two
categories. Anticipated changes are listed in Section \ref{SecAchange}, and
unlikely changes are listed in Section \ref{SecUchange}.

\subsection{Anticipated Changes} \label{SecAchange}

Anticipated changes are the source of the information that is to be hidden
inside the modules. Ideally, changing one of the anticipated changes will only
require changing the one module that hides the associated decision. The approach
adapted here is called design for
change.

\begin{description}
\item[\refstepcounter{acnum} \actheacnum \label{acHardware}:] The specific
  hardware on which the software is running.
\item[\refstepcounter{acnum} \actheacnum \label{acInput}:] The format of the
  image input data (file formats, metadata structure).
\item[\refstepcounter{acnum} \actheacnum \label{acAuth}:] The authentication
  and authorization mechanism for different user types.
\item[\refstepcounter{acnum} \actheacnum \label{acUpload}:] The method for
  uploading and storing fragment images.
\item[\refstepcounter{acnum} \actheacnum \label{acSearch}:] The algorithm used
  for searching and filtering fragments.
\item[\refstepcounter{acnum} \actheacnum \label{acEdgeMatch}:] The machine
  learning model used for edge matching detection.
\item[\refstepcounter{acnum} \actheacnum \label{acDamage}:] The algorithm for
  damage pattern analysis.
\item[\refstepcounter{acnum} \actheacnum \label{acScript}:] The method for
  script classification and similarity matching.
\item[\refstepcounter{acnum} \actheacnum \label{acOCR}:] The optical character
  recognition engine used for text extraction.
\item[\refstepcounter{acnum} \actheacnum \label{acTextSim}:] The algorithm for
  text similarity comparison.
\item[\refstepcounter{acnum} \actheacnum \label{acCanvas}:] The user interface
  framework for the interactive canvas.
\item[\refstepcounter{acnum} \actheacnum \label{acFragStore}:] The database
  schema and storage mechanism for fragment data.
\item[\refstepcounter{acnum} \actheacnum \label{acCatalog}:] The structure of
  catalog metadata.
\item[\refstepcounter{acnum} \actheacnum \label{acMatchOrch}:] The orchestration
  logic for combining multiple ML model results.
\item[\refstepcounter{acnum} \actheacnum \label{acSession}:] The session
  management and state persistence mechanism.
\end{description}

\subsection{Unlikely Changes} \label{SecUchange}

The module design should be as general as possible. However, a general system is
more complex. Sometimes this complexity is not necessary. Fixing some design
decisions at the system architecture stage can simplify the software design. If
these decision should later need to be changed, then many parts of the design
will potentially need to be modified. Hence, it is not intended that these
decisions will be changed.

\begin{description}
\item[\refstepcounter{ucnum} \uctheucnum \label{ucIO}:] Input/Output devices
  (Input: Image files via web upload, Output: Screen display and file export).
\item[\refstepcounter{ucnum} \uctheucnum \label{ucWebApp}:] The system will be
  deployed as a web-based application accessible through standard browsers.
\item[\refstepcounter{ucnum} \uctheucnum \label{ucImageProc}:] The system will
  process 2D images of manuscript fragments.
\item[\refstepcounter{ucnum} \uctheucnum \label{ucCollaborate}:] The system will
  support collaborative work through shared projects and annotations.
\item[\refstepcounter{ucnum} \uctheucnum \label{ucMLCore}:] Machine learning will
  be a core component for fragment matching and analysis.
\end{description}

\section{Module Hierarchy} \label{SecMH}

This section provides an overview of the module design. Modules are summarized
in a hierarchy decomposed by secrets in Table \ref{TblMH}. The modules listed
below, which are leaves in the hierarchy tree, are the modules that will
actually be implemented.

\begin{description}
  \item [\refstepcounter{mnum} \mthemnum \label{mHWImageStorage}:] HW.ImageStorage Module
\item [\refstepcounter{mnum} \mthemnum \label{mCanvas}:] UI.Canvas Module
\item [\refstepcounter{mnum} \mthemnum \label{mSearch}:] UI.Search Module
\item [\refstepcounter{mnum} \mthemnum \label{mAuth}:] UI.Auth Module
\item [\refstepcounter{mnum} \mthemnum \label{mUpload}:] UI.Upload Module
\item [\refstepcounter{mnum} \mthemnum \label{mAPI}:] Svc.API Module
\item [\refstepcounter{mnum} \mthemnum \label{mSearchSvc}:] Svc.Search Module
\item [\refstepcounter{mnum} \mthemnum \label{mAuthZ}:] Svc.AuthZ Module
\item [\refstepcounter{mnum} \mthemnum \label{mSession}:] Svc.Session Module
\item [\refstepcounter{mnum} \mthemnum \label{mProcOrch}:] Svc.ProcOrch Module
\item [\refstepcounter{mnum} \mthemnum \label{mMatchOrch}:] Svc.MatchOrch Module
\item [\refstepcounter{mnum} \mthemnum \label{mFragStore}:] Data.FragmentStore Module
\item [\refstepcounter{mnum} \mthemnum \label{mCatalog}:] Data.Catalog Module
\item [\refstepcounter{mnum} \mthemnum \label{mUser}:] Data.User Module
\item [\refstepcounter{mnum} \mthemnum \label{mProject}:] Data.Project Module
\item [\refstepcounter{mnum} \mthemnum \label{mEdgeMatch}:] ML.EdgeMatch Module
\item [\refstepcounter{mnum} \mthemnum \label{mDamage}:] ML.Damage Module
\item [\refstepcounter{mnum} \mthemnum \label{mScriptClass}:] ML.ScriptClass Module
\item [\refstepcounter{mnum} \mthemnum \label{mOCR}:] ML.OCR Module
\item [\refstepcounter{mnum} \mthemnum \label{mTextSim}:] ML.TextSim Module
\item [\refstepcounter{mnum} \mthemnum \label{mError}:] Error Handling Module
\item [\refstepcounter{mnum} \mthemnum \label{mLogging}:] Logging Module
\item [\refstepcounter{mnum} \mthemnum \label{mConfig}:] Configuration Management Module
\item [\refstepcounter{mnum} \mthemnum \label{mTestStubs}:] Test Stubs Module
\end{description}


\begin{table}[h!]
\centering
\begin{tabular}{p{0.3\textwidth} p{0.6\textwidth}}
\toprule
\textbf{Level 1} & \textbf{Level 2}\\
\midrule

{Hardware-Hiding Module} & ~ \\
\midrule

\multirow{7}{0.3\textwidth}{Behaviour-Hiding Module} & ?\\
& ?\\
& ?\\
& ?\\
& ?\\
& ?\\
& ?\\
& ?\\
\midrule

\multirow{3}{0.3\textwidth}{Software Decision Module} & {?}\\
& ?\\
& ?\\
\bottomrule

\end{tabular}
\caption{Module Hierarchy}
\label{TblMH}
\end{table}

\section{Connection Between Requirements and Design} \label{SecConnection}

The design of the system is intended to satisfy the requirements developed in
the SRS. In this stage, the system is decomposed into modules. The connection
between requirements and modules is listed in Table~\ref{TblRT}. \newline

FR1.1 (User Authentication) is implemented through the \mref{mAuth} and \mref{mAuthZ} modules which manage credential verification and secure access control. 
Similarly, FR1.2 (Fragment Management) and FR1.3 (Display Fragments) are supported by the \mref{mCanvas}, \mref{mUpload}, and \mref{mFragStore} modules that 
enable fragment visualization and organization. The ML-oriented requirements FR3.1-FR3.3 are implemented by specialized modules such as \mref{mEdgeMatch}, 
\mref{mDamage}, and \mref{mScriptClass}, coordinated by \mref{mMatchOrch}.

Non-functional requirements are distributed across multiple layers of the system. NFR1.1 (Usability) and NFR1.2 (Performance) are primarily addressed 
by front-end and orchestration modules to ensure responsiveness and ease of interaction. NFR2.1 (Scalability) and NFR2.2 (Reliability) are achieved through 
the use of modular orchestration, structured data storage, and robust error handling in modules such as \mref{mProcOrch}, \mref{mCatalog}, and \mref{mError}. 
Finally, NFR3.1-NFR3.3 (Accuracy, Efficiency, and Maintainability) govern the design of the AI/ML cluster, ensuring that the models (\mref{mEdgeMatch}, 
\mref{mDamage}, \mref{mTextSim}) can be retrained, tuned, and maintained without disrupting other components.

\section{Module Decomposition} \label{SecMD}

Modules are decomposed according to the principle of ``information hiding''
proposed by \citet{ParnasEtAl1984}. The \emph{Secrets} field in a module
decomposition is a brief statement of the design decision hidden by the
module. The \emph{Services} field specifies \emph{what} the module will do
without documenting \emph{how} to do it. For each module, a suggestion for the
implementing software is given under the \emph{Implemented By} title. If the
entry is \emph{OS}, this means that the module is provided by the operating
system or by standard programming language libraries.  \emph{\progname{}} means the
module will be implemented by the \progname{} software.

Only the leaf modules in the hierarchy have to be implemented. If a dash
(\emph{--}) is shown, this means that the module is not a leaf and will not have
to be implemented.

\subsection{Hardware Hiding Modules}

\begin{description}
\item[Secrets:]The data structure and algorithm used to implement the virtual
  hardware.
\item[Services:]Serves as a virtual hardware used by the rest of the
  system. This module provides the interface between the hardware and the
  software. So, the system can use it to display outputs or to accept inputs.
\item[Implemented By:] OS
\end{description}

\subsubsection{HW.ImageStorage (\mref{mHWImageStorage})}

\begin{description}
\item[Secrets:] Data structure and algorithms used to implement the image storage
\item[Services:] This module provides platform-specific file operations such as image storage and retrieval, and it serves as virtual hardware for the system.  
\item[Implemented By:] Cloud or Local Storage Interface
\item[Type of Module:] Abstract Object
\end{description}



\subsection{Behaviour-Hiding Module}

\begin{description}
\item[Secrets:]The contents of the required behaviours.
\item[Services:]Includes programs that provide externally visible behaviour of
  the system as specified in the software requirements specification (SRS)
  documents. This module serves as a communication layer between the
  hardware-hiding module and the software decision module. The programs in this
  module will need to change if there are changes in the SRS.
\item[Implemented By:] --
\end{description}

\subsubsection{UI.Canvas (\mref{mCanvas})}

\begin{description}
\item[Secrets:] The implementation of the interactive canvas for fragment manipulation.
\item[Services:] Provides an interactive interface to arrange multiple fragments and displays match suggestions
\item[Implemented By:] Front-End Web Client (React/Next.js component)
\item[Type of Module:] Abstract Object
\end{description}

\subsubsection{UI.Search (\mref{mSearch})}

\begin{description}
\item[Secrets:] The user interface design for search and filtering functionality.
\item[Services:] Provides a search interface for fragments, and supports search by script type, line count, and fragment size.
\item[Implemented By:] Front-End Web Client (React/Next.js component)
\item[Type of Module:] Abstract Object
\end{description}

\subsubsection{UI.Auth (\mref{mAuth})}

\begin{description}
\item[Secrets:] The user interface for authentication and user management.
\item[Services:] Provides login/logout interface, user registration, role-based access control UI, and session management display.
\item[Implemented By:] Front-End Authentication Component
\item[Type of Module:] Abstract Object
\end{description}

\subsubsection{UI.Upload (\mref{mUpload})}

\begin{description}
\item[Secrets:] The user interface for uploading fragment images and metadata.
\item[Services:] Provides a file upload interface to select and submit images to the backend for processing after validation.
\item[Implemented By:] Front-End Web Client (React/Next.js component)
\item[Type of Module:] Abstract Object
\end{description}

\subsubsection{Svc.API (\mref{mAPI})}

\begin{description}
\item[Secrets:] The RESTful API endpoint definitions and routing logic.
\item[Services:] Sends incoming HTTP requests from the UI to services and handles request validation
\item[Implemented By:] Backend API Gateway (FastAPI, Flask, or Node.js)
\item[Type of Module:] Abstract Object
\end{description}

\subsubsection{Svc.Search (\mref{mSearchSvc})}

\begin{description}
\item[Secrets:] The search algorithm and query optimization logic.
\item[Services:] This module performs efficient fragment searches over metadata and fragments, and it can export the results as a PDF or CSV file
\item[Implemented By:] Backend Search Service 
\item[Type of Module:] Abstract Object
\end{description}

\subsubsection{Svc.AuthZ (\mref{mAuthZ})}

\begin{description}
\item[Secrets:] The authentication and authorization implementation.
\item[Services:] This module validates user credentials and tokens, and it enforces access control for protected operations
\item[Implemented By:] Authentication & Authorization Microservice
\item[Type of Module:] Abstract Object
\end{description}

\subsubsection{Svc.Session (\mref{mSession})}

\begin{description}
\item[Secrets:] The session state management and persistence mechanism.
\item[Services:] Manages user sessions and provides storage and retrieval of the saved user workspace
\item[Implemented By:] Backend Session Manager
\item[Type of Module:] Abstract Object
\end{description}

\subsubsection{Svc.ProcOrch (\mref{mProcOrch})}

\begin{description}
\item[Secrets:] The orchestration logic for image processing pipelines.
\item[Services:] Coordinates preprocessing workflows for images uploaded by user, and manages job queues for ML tasks
\item[Implemented By:] Workflow Orchestrator
\item[Type of Module:] Abstract Object
\end{description}

\subsubsection{Svc.MatchOrch (\mref{mMatchOrch})}

\begin{description}
\item[Secrets:] The algorithm for combining results from multiple ML models.
\item[Services:] Aggregates and sorts results from all ML models and provides confidence scores
\item[Implemented By:] Backend Orchestrator Service
\item[Type of Module:] Abstract Object
\end{description}

\subsubsection{Data.FragmentStore (\mref{mFragStore})}

\begin{description}
\item[Secrets:] The database schema and queries for fragment storage.
\item[Services:] Stores and retrieves fragment entities such as fragment IDs, associated image IDs, script labels, line counts, and status flags  
\item[Implemented By:] Data Access Layer
\item[Type of Module:] Abstract Data Type
\end{description}

\subsubsection{Data.Catalog (\mref{mCatalog})}

\begin{description}
\item[Secrets:] The catalog metadata structure and taxonomy.
\item[Services:] Stores mappings between internal fragments and external catalogue identifiers
\item[Implemented By:] Metadata Database
\item[Type of Module:] Abstract Data Type
\end{description}

\subsubsection{Data.User (\mref{mUser})}

\begin{description}
\item[Secrets:] The user data model and storage.
\item[Services:] Stores all user information such as accounts, credentials, roles and profile information for authentication and access control purposes
\item[Implemented By:] User Account Database Table
\item[Type of Module:] Record
\end{description}

\subsubsection{Data.Project (\mref{mProject})}

\begin{description}
\item[Secrets:] The project data structure for collaborative work.
\item[Services:] Manages project workspaces and collections and stores project-specific fragment groupings
\item[Implemented By:] Project Database Schema
\item[Type of Module:] Record
\end{description}

\subsubsection{ML.EdgeMatch (\mref{mEdgeMatch})}

\begin{description}
\item[Secrets:] Model details including weights and hyperparameters, segmentation mask and edge matching algorithms.
\item[Services:] Provides edge match similarity probability and computes edge features for images.
\item[Implemented By:] AI/ML Cluster (Python-based ML Service)
\item[Type of Module:] Abstract Object
\end{description}


\subsubsection{ML.Damage (\mref{mDamage})}

\begin{description}
\item[Secrets:] Physical damage information and hyperparameters for damage segmentation.
\item[Services:] Determines similarity score for damage and generates signatures for damage in fragments. 
\item[Implemented By:] AI/ML Cluster (Python-based ML Service)
\item[Type of Module:] Abstract Object
\end{description}


\subsubsection{ML.ScriptClass (\mref{mScriptClass})}

\begin{description}
\item[Secrets:] Model architecture and hyperparameters, and script label and metadata.
\item[Services:] Determines the type of script based on text in the script and provides the script label with a confidence score.
\item[Implemented By:] AI/ML Cluster (Text Classification Service)
\item[Type of Module:] Abstract Object
\end{description}


\subsubsection{ML.OCR (\mref{mOCR})}

\begin{description} 
\item[Secrets:] Hyperparameters, weights, thresholds and algorithms used for OCR model
\item[Services:] This module analyzes fragments to find transcribed text with associated confidence scores, and it provides approximate accuracy values.
\item[Implemented By:] AI/ML Cluster (OCR Model Server)
\item[Type of Module:] Abstract Object
\end{description}


\subsubsection{ML.TextSim (\mref{mTextSim})}

\begin{description}
\item[Secrets:] Vectorization and normalization methods, and algorithm used for checking similarity
\item[Services:] Converts text to embedding vector and compares similarity between text segments using OCR or manual transcription
\item[Implemented By:] AI/ML Cluster (Text Similarity Service)
\item[Type of Module:] Abstract Object
\end{description}

\subsection{Software Decision Module}

\begin{description}
\item[Secrets:] The design decision based on mathematical theorems, physical
  facts, or programming considerations. The secrets of this module are
  \emph{not} described in the SRS.
\item[Services:] Includes data structure and algorithms used in the system that
  do not provide direct interaction with the user.
  % Changes in these modules are more likely to be motivated by a desire to
  % improve performance than by externally imposed changes.
\item[Implemented By:] --
\end{description}

\subsubsection{Util.Error (\mref{mError})}

\begin{description}
\item[Secrets:] The error handling and exception management plan
\item[Services:] Defines standard error types and provides centralized error handling across all modules
\item[Implemented By:] Shared Backend Utility Package
\item[Type of Module:] Library
\end{description}


\subsubsection{Util.Logging (\mref{mLogging})}

\begin{description}
\item[Secrets:] The logging implementation and structure of the log format
\item[Services:] This module records system events and user actions, and it provides structured logging for information, warnings and errors.
\item[Implemented By:] Shared Logging Framework
\item[Type of Module:] Library
\end{description}


\subsubsection{Util.Config (\mref{mConfig})}

\begin{description}
\item[Secrets:] The configuration format and loading mechanism
\item[Services:] Loads configuration from files and provides read-only access to configuration values by providing the value or boolean based on key given.
\item[Implemented By:] Configuration Manager
\item[Type of Module:] Library
\end{description}

\subsubsection{Util.TestStub (\mref{mTestStubs})}

\begin{description}
\item[Secrets:] The mock implementations and mock model outputs
\item[Services:] This module provides stub implementations of services and ML components, and it simulates ML model responses
\item[Implemented By:] Test Utilities
\item[Type of Module:] Library
\end{description}

\section{Traceability Matrix} \label{SecTM}

This section shows two traceability matrices: between the modules and the
requirements and between the modules and the anticipated changes.

% the table should use mref, the requirements should be named, use something
% like fref
\begin{table}[H]
\centering
\begin{tabular}{p{0.2\textwidth} p{0.6\textwidth}}
\toprule
\textbf{Req.} & \textbf{Modules}\\
\midrule
FR1.1 & \mref{mAuth}, \mref{mAuthZ}, \mref{mSession}, \mref{mUser}\\
FR1.2 & \mref{mCanvas}, \mref{mUpload}, \mref{mAPI}, \mref{mProcOrch}, \mref{mFragStore}, \mref{mCatalog}\\
FR1.3 & \mref{mCanvas}, \mref{mSearch}, \mref{mAPI}\\
FR1.4 & \mref{mCanvas}, \mref{mMatchOrch}, \mref{mEdgeMatch}, \mref{mDamage}, \mref{mScriptClass}, \mref{mOCR}, \mref{mTextSim}, \mref{mFragStore}\\
FR1.5 & \mref{mCanvas}, \mref{mAuth}, \mref{mSession}, \mref{mProject}\\
NFR1.1 & \mref{mCanvas}, \mref{mSearch}, \mref{mAuth}, \mref{mUpload}\\
NFR1.2 & \mref{mHWImageStorage}, \mref{mCanvas}, \mref{mUpload}, \mref{mAPI}\\
FR2.1 & \mref{mAPI}, \mref{mAuthZ}, \mref{mSession}, \mref{mMatchOrch}\\
FR2.2 & \mref{mAuthZ}, \mref{mSession}, \mref{mUser}\\
FR2.3 & \mref{mFragStore}, \mref{mCatalog}, \mref{mUser}, \mref{mProject}\\
NFR2.1 & \mref{mAPI}, \mref{mProcOrch}, \mref{mMatchOrch}, \mref{mHWImageStorage}\\
NFR2.2 & \mref{mFragStore}, \mref{mCatalog}, \mref{mUser}, \mref{mProject}, \mref{mError}, \mref{mLogging}, \mref{mConfig}\\
FR3.1 & \mref{mEdgeMatch}, \mref{mMatchOrch}\\
FR3.2 & \mref{mScriptClass}, \mref{mMatchOrch}\\
FR3.3 & \mref{mDamage}, \mref{mMatchOrch}\\
NFR3.1 & \mref{mEdgeMatch}, \mref{mDamage}, \mref{mScriptClass}, \mref{mOCR}, \mref{mTextSim}\\
NFR3.2 & \mref{mEdgeMatch}, \mref{mDamage}, \mref{mScriptClass}, \mref{mOCR}, \mref{mTextSim}, \mref{mProcOrch}, \mref{mMatchOrch}\\
NFR3.3 & \mref{mEdgeMatch}, \mref{mDamage}, \mref{mScriptClass}, \mref{mOCR}, \mref{mTextSim}, \mref{mLogging}, \mref{mConfig}, \mref{mTestStubs}\\

\bottomrule
\end{tabular}
\caption{Trace Between Requirements and Modules}
\label{TblRT}
\end{table}

\begin{table}[H]
\centering
\begin{tabular}{p{0.2\textwidth} p{0.6\textwidth}}
\toprule
\textbf{AC} & \textbf{Modules}\\
\midrule
\acref{acHardware} & \mref{mHWImageStorage}, \mref{mConfig}\\
\acref{acInput} & \mref{mUpload}, \mref{mProcOrch}, \mref{mHWImageStorage}\\
\acref{acAuth} & \mref{mAuth}, \mref{mAuthZ}, \mref{mUser}, \mref{mSession}, \mref{mAPI}\\
\acref{acUpload} & \mref{mUpload}, \mref{mProcOrch}, \mref{mFragStore}\\
\acref{acSearch} & \mref{mSearch}, \mref{mSearchSvc}, \mref{mCatalog}\\
\acref{acEdgeMatch} & \mref{mEdgeMatch}, \mref{mMatchOrch}\\
\acref{acDamage} & \mref{mDamage}, \mref{mMatchOrch}\\
\acref{acScript} & \mref{mScriptClass}, \mref{mMatchOrch}\\
\acref{acOCR} & \mref{mOCR}, \mref{mProcOrch}\\
\acref{acTextSim} & \mref{mTextSim}, \mref{mMatchOrch}\\
\acref{acCanvas} & \mref{mCanvas}, \mref{mSearch}, \mref{mUpload}\\
\acref{acFragStore} & \mref{mFragStore}, \mref{mCatalog}, \mref{mProject}\\
\acref{acCatalog} & \mref{mCatalog}, \mref{mSearchSvc}\\
\acref{acMatchOrch} & \mref{mMatchOrch}, \mref{mEdgeMatch}, \mref{mDamage}, \mref{mScriptClass}, \mref{mOCR}, \mref{mTextSim}\\
\acref{acSession} & \mref{mSession}, \mref{mUser}, \mref{mProject}, \mref{mAuthZ}\\
\bottomrule
\end{tabular}
\caption{Trace Between Anticipated Changes and Modules}
\label{TblACT}
\end{table}

\section{Use Hierarchy Between Modules} \label{SecUse}

In this section, the uses hierarchy between modules is
provided. \citet{Parnas1978} said of two programs A and B that A {\em uses} B if
correct execution of B may be necessary for A to complete the task described in
its specification. That is, A {\em uses} B if there exist situations in which
the correct functioning of A depends upon the availability of a correct
implementation of B.  Figure \ref{FigUH} illustrates the use relation between
the modules. It can be seen that the graph is a directed acyclic graph
(DAG). Each level of the hierarchy offers a testable and usable subset of the
system, and modules in the higher level of the hierarchy are essentially simpler
because they use modules from the lower levels.

\wss{The uses relation is not a data flow diagram.  In the code there will often
be an import statement in module A when it directly uses module B.  Module B
provides the services that module A needs.  The code for module A needs to be
able to see these services (hence the import statement).  Since the uses
relation is transitive, there is a use relation without an import, but the
arrows in the diagram typically correspond to the presence of import statement.}

\wss{If module A uses module B, the arrow is directed from A to B.}

\begin{figure}[H]
\centering
%\includegraphics[width=0.7\textwidth]{UsesHierarchy.png}
\caption{Use hierarchy among modules}
\label{FigUH}
\end{figure}

%\section*{References}

\section{User Interfaces}

\wss{Design of user interface for software and hardware.  Attach an appendix if
needed. Drawings, Sketches, Figma}

\section{Design of Communication Protocols}

\wss{If appropriate}

\section{Timeline}

\wss{Schedule of tasks and who is responsible}

\wss{You can point to GitHub if this information is included there}

\bibliographystyle {plainnat}
\bibliography{../../../refs/References}

\newpage{}

\end{document}