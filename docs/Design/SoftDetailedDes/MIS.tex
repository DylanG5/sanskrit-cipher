\documentclass[12pt, titlepage]{article}

\usepackage{amsmath, mathtools}

\usepackage[round]{natbib}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{colortbl}
\usepackage{xr}
\usepackage{hyperref}
\usepackage{longtable}
\usepackage{xfrac}
\usepackage{tabularx}
\usepackage{float}
\usepackage{siunitx}
\usepackage{booktabs}
\usepackage{multirow}
\usepackage[section]{placeins}
\usepackage{caption}
\usepackage{fullpage}
\usepackage{booktabs}
\usepackage[T1]{fontenc}


\hypersetup{
bookmarks=true,     % show bookmarks bar?
colorlinks=true,       % false: boxed links; true: colored links
linkcolor=red,          % color of internal links (change box color with linkbordercolor)
citecolor=blue,      % color of links to bibliography
filecolor=magenta,  % color of file links
urlcolor=cyan          % color of external links
}

\usepackage{array}

\externaldocument{../../SRS/SRS}

\input{../../Comments}
\input{../../Common}

\begin{document}

\title{Module Interface Specification for \progname{}}

\author{\authname}

\date{\today}

\maketitle

\pagenumbering{roman}

\section{Revision History}

\begin{tabularx}{\textwidth}{p{3cm}p{2cm}X}
\toprule {\bf Date} & {\bf Version} & {\bf Notes}\\
\midrule
Date 1 & 1.0 & Notes\\
Date 2 & 1.1 & Notes\\
\bottomrule
\end{tabularx}

~\newpage

\section{Symbols, Abbreviations and Acronyms}

See SRS Documentation at \wss{give url}

\wss{Also add any additional symbols, abbreviations or acronyms}

\newpage

\tableofcontents

\newpage


\pagenumbering{arabic}

\section{Introduction}

The following document details the Module Interface Specifications (MIS) for the Sanskrit Manuscript Fragment Reconstruction Platform (SMFRP). This system supports researchers and scholars in reconstructing fragmented Sanskrit manuscripts by providing a unified digital workspace that integrates fragment management, intelligent matching, and image-based reconstruction tools.

The MIS defines the external behavior and interfaces for each software module in the system. Each module is specified in terms of its responsibilities, provided services, hidden state (secrets), environment variables, and exported access programs. These specifications are written at the right level of abstraction, focusing on logical interfaces and responsibilities rather than low-level implementation details such as programming language syntax or data structures.

This document ensures that the system achieves consistency, and minimal coupling across modules. The defined interfaces promote high cohesion, and generality, enabling independent development, verification, and maintenance of each module.

\subsection*{Complementary Documents}
\begin{itemize}
    \item \textbf{System Requirements Specification (SRS)} – Defines the system’s functional and non-functional requirements. The SRS can be accessed at: \href{https://github.com/DylanG5/sanskrit-ciphers-requirements/tree/ab899d5d07b554c8e80fb4fc8a8adaa181a0c81a}{SRS}
    \item \textbf{Module Guide (MG)} – Outlines the overall software architecture, module decomposition, and dependency hierarchy.
\end{itemize}

\subsection*{Repository}
The full project documentation and implementation can be found in the team’s \href{https://github.com/DylanG5/sanskrit-cipher}{GitHub repository}  

\section{Notation}

In this section, we define the notation used throughout the Module Interface Specification. The purpose of this notation is to describe, in a clear and consistent manner, what each module provides and requires, without referencing any specific programming language or implementation detail.

Each module in this MIS is described in terms of:
\begin{itemize}
    \item \textbf{State Variables} – The module’s internal data that is not visible externally.
    \item \textbf{Environment Variables} – Data received from or affecting the external environment (e.g., databases, file storage, APIs).
    \item \textbf{Exported Constants and Access Programs} – The operations, services, or functions the module provides to other modules.
\end{itemize}

This approach focuses on interface behavior, not implementation syntax (such as JSON or Python code), ensuring that the interfaces remain consistent.

\subsection{Primitive Data Types}

\begin{table}[H]
\centering
\caption{Primitive Data Types}
\begin{tabular}{lll}
\toprule
\textbf{Data Type} & \textbf{Notation} & \textbf{Description} \\
\midrule
Character & \texttt{char} & A single symbol or letter. \\
Integer & \texttt{int} & Whole numbers with no fractional part. \\
Real & \texttt{float} & Numbers with decimal or fractional parts. \\
Boolean & \texttt{bool} & Represents logical truth values (true or false). \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Derived Data Types}

In addition to the primitive types above, the system specification also makes use of the following derived or composite types:

\begin{itemize}
    \item \textbf{Sequence:} An ordered collection of elements of the same data type. Example: A list of fragment identifiers or saved user sessions.
    \item \textbf{String:} A sequence of characters, typically used for textual input, labels, or metadata fields.
    \item \textbf{Tuple:} An ordered collection of values that may be of different data types. Commonly used to represent grouped entities such as \texttt{(FragmentId, ConfidenceScore)} or \texttt{(x, y, width, height)}.
    \item \textbf{Record / Object:} A structured type that groups named fields with defined data types, such as \texttt{\{id: FragmentId, script: String, confidence: Float\}}.
    \item \textbf{Function:} A mapping defined by the types of its inputs and outputs. Functions are specified by their type signatures (inputs/outputs) and behavior (preconditions, postconditions, and effects).
\end{itemize}

\subsection{Interface and Parameter Conventions}

This section explains how interfaces and operations are written in the MIS. The goal is to make them easy to read and understand while staying general enough to apply to any implementation.

\begin{itemize}
    \item \textbf{Inputs and Outputs:} Labeled as \texttt{in:} and \texttt{out:} in operation definitions. Example: \texttt{search(in: SearchQuery, out: SearchResult)}
    \item \textbf{Operation Format:} \texttt{functionName(in: InputType, out: OutputType) → may throw ErrorType}
    \item \textbf{Module Naming Convention:} Each module name follows the format \texttt{Layer.Module}, for example: \texttt{UI.Canvas}, \texttt{Svc.MatchOrch}, or \texttt{Data.FragmentStore}.
    \item \textbf{Boolean Conditions:} Represented using logical symbols such as $\land$ (and), $\lor$ (or), $\lnot$ (not), and $\implies$ (implies).
\end{itemize}


\section{Module Decomposition}



The following section summarizes the module hierarchy for the \textit{Sanskrit Manuscript Fragment Reconstruction Platform}. It is consistent with the \textbf{Module Guide (MG)} for this project and represents how the system has been decomposed into modules at different abstraction levels.

Each level in the hierarchy captures a different design concern:

\begin{itemize}
    \item \textbf{Hardware-Hiding Level:} Interfaces directly with the system’s physical or platform-dependent resources.
    \item \textbf{Behaviour-Hiding Level:} Encapsulates the main functional behavior of the system, implementing the use cases described in the SRS.
    \item \textbf{Software Decision Level:} Contains lower-level utility modules and software decisions that simplify implementation but are not visible to the user.
\end{itemize}

\subsection{Module Hierarchy}

\begin{table}[h!]
\centering
\caption{Module Hierarchy}
\small
\begin{tabular}{ll}
\toprule
\textbf{Level 1} & \textbf{Level 2 Modules} \\
\midrule
Hardware-Hiding (HW) & Image Storage Interface \\
\addlinespace
Behaviour-Hiding & 
\begin{minipage}[t]{0.7\linewidth}
\textbf{User Interface (UI):} \texttt{UI.Canvas}, \texttt{UI.Search}, \texttt{UI.Auth}, \texttt{UI.Upload}\\
\textbf{Service Layer (Svc):} \texttt{Svc.API}, \texttt{Svc.Search}, \texttt{Svc.AuthZ}, \texttt{Svc.Session}, \texttt{Svc.ProcOrch}, \texttt{Svc.MatchOrch}\\
\textbf{Data Management (Data):} \texttt{Data.FragmentStore}, \texttt{Data.Catalog}, \texttt{Data.User}, \texttt{Data.Project}\\
\textbf{Machine Learning Modules (ML):} \texttt{ML.EdgeMatch}, \texttt{ML.Damage}, \texttt{ML.ScriptClass}, \texttt{ML.OCR}, \texttt{ML.TextSim}
\end{minipage} \\
\addlinespace
Software Decision & 
\begin{minipage}[t]{0.7\linewidth}
Utility and Support Modules (Error Handling, Logging, Configuration Management, Test Stubs)
\end{minipage} \\
\bottomrule
\end{tabular}
\end{table}

\newpage

\subsection{Description of Levels}

\subsubsection{Hardware-Hiding Level}
This level hides all hardware and platform dependencies from the rest of the system. It includes interfaces that communicate with the file storage system, image repositories, and cloud infrastructure. These components provide a uniform interface for accessing images and metadata regardless of the underlying storage medium.

\subsubsection{Behaviour-Hiding Level}
This level defines the functional behavior of the system, implementing the requirements outlined in the SRS. It includes the user-facing modules (UI), the application logic (Service Layer), data persistence (Data Layer), and intelligent processing (ML Layer). These modules interact through clearly defined service interfaces, promoting modularity and separation of concerns.

\subsubsection{Software Decision Level}
This level includes supporting components that are primarily design decisions rather than functional necessities. These modules include configuration handlers, utility libraries, and testing or logging frameworks that support development, debugging, and maintenance.


\section{MIS of \wss{Module Name}} \label{Module} \wss{Use labels for
  cross-referencing}

\wss{You can reference SRS labels, such as R\ref{R_Inputs}.}

\wss{It is also possible to use \LaTeX for hypperlinks to external documents.}

\subsection{Module}

\wss{Short name for the module}

\subsection{Uses}


\subsection{Syntax}

\subsubsection{Exported Constants}

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{2cm} p{4cm} p{4cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
\wss{accessProg} & - & - & - \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}

\wss{Not all modules will have state variables.  State variables give the module
  a memory.}

\subsubsection{Environment Variables}

\wss{This section is not necessary for all modules.  Its purpose is to capture
  when the module has external interaction with the environment, such as for a
  device driver, screen interface, keyboard, file, etc.}

\subsubsection{Assumptions}

\wss{Try to minimize assumptions and anticipate programmer errors via
  exceptions, but for practical purposes assumptions are sometimes appropriate.}

\subsubsection{Access Routine Semantics}

\noindent \wss{accessProg}():
\begin{itemize}
\item transition: \wss{if appropriate} 
\item output: \wss{if appropriate} 
\item exception: \wss{if appropriate} 
\end{itemize}

\wss{A module without environment variables or state variables is unlikely to
  have a state transition.  In this case a state transition can only occur if
  the module is changing the state of another module.}

\wss{Modules rarely have both a transition and an output.  In most cases you
  will have one or the other.}

\subsubsection{Local Functions}

\wss{As appropriate} \wss{These functions are for the purpose of specification.
  They are not necessarily something that is going to be implemented
  explicitly.  Even if they are implemented, they are not exported; they only
  have local scope.}

\newpage

\bibliographystyle {plainnat}
\bibliography {../../../refs/References}

\newpage

\section{Appendix} \label{Appendix}

\wss{Extra information if required}

\newpage{}

\section*{Appendix --- Reflection}

The information in this section will be used to evaluate the team members on the
graduate attribute of Problem Analysis and Design.


\begin{enumerate}
  \item What went well while writing this deliverable? 
  
    \hspace{2em} One aspect that went particularly well was identifying the appropriate notation and determining which modules needed to be included in the design. Our team communicated effectively throughout this process, which helped us maintain a shared understanding of the system and its structure. Because we already had a strong grasp of the project vision, it was relatively easy to map our ideas into a formal design representation. As a result, we were able to present a clear and coherent picture of the system architecture that reflects both the requirements and the intended functionality.

  \item What pain points did you experience during this deliverable, and how
    did you resolve them?

    \hspace{2em} The main challenge we encountered was thinking through the lower-level implementation details. At this stage, we have not yet progressed far into the actual coding, so some of the design decisions, especially those related to specific algorithms, data structures, and system interactions required educated assumptions rather than concrete experience. We addressed this by focusing on higher-level abstractions and deferring detailed implementation decisions until we gain more clarity during development. This allowed us to complete the deliverable while still leaving room for necessary adjustments later.

  \item Which of your design decisions stemmed from speaking to your client(s)
  or a proxy (e.g. your peers, stakeholders, potential users)? For those that
  were not, why, and where did they come from?

    \hspace{2em} Many of our design decisions, especially those involving the user interface, were directly influenced by conversations with our supervisor, Dr. Shayne. Since he does not come from a technical background, he primarily expressed his needs in terms of how he wanted to interact with the system. This naturally shaped the UI and the workflow we designed for scholars. Additionally, the inclusion of segmentation-based machine learning came from his explicit request; he emphasized that automated assistance in identifying and matching fragments would significantly improve his research workflow. These inputs helped anchor our design choices in real user needs.

  \item While creating the design doc, what parts of your other documents (e.g.
  requirements, hazard analysis, etc), it any, needed to be changed, and why?

    \hspace{2em} Very few changes were needed to our previous documents. Because this is a pre-approved project with a well-defined problem and scope, many of the requirements and expectations were already laid out for us in the project description. As a result, our earlier documents, such as the SRS and Hazard Analysis, aligned naturally with the design work we did here. We did not need to revisit or adjust them significantly, beyond minor wording refinements and consistency updates.

  \item What are the limitations of your solution?  Put another way, given
  unlimited resources, what could you do to make the project better? (LO\_ProbSolutions)

    \hspace{2em} With unlimited resources, one of the most impactful improvements would be investing in more powerful AI infrastructure, such as GPUs dedicated to training and evaluating models. This would allow us to train new segmentation or matching models more frequently and at a much larger scale. We would also aim to build a more advanced fragment-matching pipeline with higher accuracy and more robust behaviour across different manuscript types. Additionally, we would elevate the quality of the UI significantly, improving performance, adding more interactive tools, and making the interface cleaner and more intuitive. Overall, the entire system could operate at a higher level of precision, speed, and sophistication.

  \item Give a brief overview of other design solutions you considered.  What
  are the benefits and tradeoffs of those other designs compared with the chosen
  design?  From all the potential options, why did you select the documented design?
  (LO\_Explores)

    \hspace{2em} We did not explore many alternative designs because, from early discussions, the entire team already shared a clear mental model of how the system should operate. Our frequent conversations kept us aligned on the major components and workflow, so we naturally converged on a single coherent design. Although this meant we did not formally evaluate multiple competing solutions, the advantage was that we were able to focus our efforts on developing one strong, detailed design rather than splitting time considering options that did not align with the client’s expectations. Given the clarity of the problem and the constraints provided, the chosen design was the most straightforward and appropriate path forward.

\end{enumerate}


\end{document}