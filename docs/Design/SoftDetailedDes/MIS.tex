\documentclass[12pt, titlepage]{article}

\usepackage{amsmath, mathtools}

\usepackage[round]{natbib}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{colortbl}
\usepackage{xr}
\usepackage{hyperref}
\usepackage{longtable}
\usepackage{xfrac}
\usepackage{tabularx}
\usepackage{float}
\usepackage{siunitx}
\usepackage{booktabs}
\usepackage{multirow}
\usepackage[section]{placeins}
\usepackage{caption}
\usepackage{fullpage}
\usepackage{booktabs}
\usepackage[T1]{fontenc}


\hypersetup{
bookmarks=true,     % show bookmarks bar?
colorlinks=true,       % false: boxed links; true: colored links
linkcolor=red,          % color of internal links (change box color with linkbordercolor)
citecolor=blue,      % color of links to bibliography
filecolor=magenta,  % color of file links
urlcolor=cyan          % color of external links
}

\usepackage{array}

\externaldocument{../../SRS/SRS}

\input{../../Comments}
\input{../../Common}

\begin{document}

\title{Module Interface Specification for \progname{}}

\author{\authname}

\date{\today}

\maketitle

\pagenumbering{roman}

\section{Revision History}

\begin{tabularx}{\textwidth}{p{3cm}p{2cm}X}
\toprule {\bf Date} & {\bf Version} & {\bf Notes}\\
\midrule

Nov.\ 13, 2025 & 1.0 & Added Section 2: Symbols, Abbreviations and Acronyms.\\
Nov.\ 13, 2025 & 1.1 & Added Section 3: Introduction.\\
Nov.\ 13, 2025 & 1.2 & Added Section 4: Notation.\\
Jan.\ 18, 2025 & 1.3 & Added Section 5: Module Decomposition.\\
Jan.\ 18, 2025 & 1.4 & Added Sections 6--29: Module Interface Specifications for all modules.\\
Nov.\ 13, 2025 & 1.5 & Added Reflection and References\\

\bottomrule
\end{tabularx}

~\newpage

\section{Symbols, Abbreviations and Acronyms}

The following symbols, abbreviations, and acronyms are used throughout this Module Interface Specification (MIS):

\subsection*{Project-Specific}
\begin{itemize}
    \item \textbf{SMFRP} — Sanskrit Manuscript Fragment Reconstruction Platform
    \item \textbf{SRS} — System Requirements Specification
    \item \textbf{MG} — Module Guide
    \item \textbf{MIS} — Module Interface Specification
\end{itemize}

\subsection*{Layer \& Module Prefixes}
\begin{itemize}
    \item \textbf{HW} — Hardware-Hiding Level
    \item \textbf{UI} — User Interface Layer
    \item \textbf{Svc} — Service Layer
    \item \textbf{ML} — Machine Learning Layer
    \item \textbf{Data} — Data Management Layer
    \item \textbf{Util} — Utility / Software Decision Level
\end{itemize}

\subsection*{UI / Web Terms}
\begin{itemize}
    \item \textbf{DOM} — Document Object Model
    \item \textbf{UI} — User Interface
    \item \textbf{HTML} — HyperText Markup Language
    \item \textbf{API} — Application Programming Interface
    \item \textbf{URL} — Uniform Resource Locator
\end{itemize}

\subsection*{Data Types \& Structures}
\begin{itemize}
    \item \textbf{ID} — Identifier (e.g., ImageID, FragmentID)
    \item \textbf{MB} — Megabyte
    \item \textbf{JSON} — JavaScript Object Notation
    \item \textbf{HTTP} — Hypertext Transfer Protocol
    \item \textbf{REST} — Representational State Transfer
\end{itemize}

\subsection*{Exceptions / Errors}
\begin{itemize}
    \item \textbf{UIRenderError} — User Interface Rendering Error
    \item \textbf{NetworkError} — Network Communication Error
    \item \textbf{ValidationError} — Input Validation Error
    \item \textbf{UploadError} — File Upload Failure
    \item \textbf{AuthError} — Authentication Error
    \item \textbf{NotFoundError} — Missing Resource
    \item \textbf{StorageWriteError} / \textbf{StorageReadError} — File I/O Problems
\end{itemize}

\subsection*{Machine Learning Terms}
\begin{itemize}
    \item \textbf{OCR} — Optical Character Recognition
    \item \textbf{ML} — Machine Learning
\end{itemize}

\newpage

\tableofcontents

\newpage

\listoftables

\newpage

\pagenumbering{arabic}

\section{Introduction}

The following document details the Module Interface Specifications (MIS) for the Sanskrit Manuscript Fragment Reconstruction Platform (SMFRP). This system supports researchers and scholars in reconstructing fragmented Sanskrit manuscripts by providing a unified digital workspace that integrates fragment management, intelligent matching, and image-based reconstruction tools.

The MIS defines the external behavior and interfaces for each software module in the system. Each module is specified in terms of its responsibilities, provided services, hidden state (secrets), environment variables, and exported access programs. These specifications are written at the right level of abstraction, focusing on logical interfaces and responsibilities rather than low-level implementation details such as programming language syntax or data structures.

This document ensures that the system achieves consistency, and minimal coupling across modules. The defined interfaces promote high cohesion, and generality, enabling independent development, verification, and maintenance of each module.

\subsection*{Complementary Documents}
\begin{itemize}
    \item \textbf{System Requirements Specification (SRS)} – Defines the system’s functional and non-functional requirements. The SRS \citep{SRS-Sanskrit-Ciphers} can be accessed at: \href{https://github.com/DylanG5/sanskrit-ciphers-requirements/tree/ab899d5d07b554c8e80fb4fc8a8adaa181a0c81a}{SRS}
    \item \textbf{Module Guide (MG)} – Outlines the overall software architecture, module decomposition, and dependency hierarchy.
\end{itemize}

\subsection*{Repository}
The full project documentation and implementation can be found in the team’s \href{https://github.com/DylanG5/sanskrit-cipher}{GitHub repository}  

\section{Notation}

In this section, we define the notation used throughout the Module Interface Specification. The purpose of this notation is to describe, in a clear and consistent manner, what each module provides and requires, without referencing any specific programming language or implementation detail.

Each module in this MIS is described in terms of:
\begin{itemize}
    \item \textbf{State Variables} – The module’s internal data that is not visible externally.
    \item \textbf{Environment Variables} – Data received from or affecting the external environment (e.g., databases, file storage, APIs).
    \item \textbf{Exported Constants and Access Programs} – The operations, services, or functions the module provides to other modules.
\end{itemize}

This approach focuses on interface behavior, not implementation syntax (such as JSON or Python code), ensuring that the interfaces remain consistent.

\subsection{Primitive Data Types}

\begin{table}[H]
\centering
\caption{Primitive Data Types}
\begin{tabular}{lll}
\toprule
\textbf{Data Type} & \textbf{Notation} & \textbf{Description} \\
\midrule
Character & \texttt{char} & A single symbol or letter. \\
Integer & \texttt{int} & Whole numbers with no fractional part. \\
Real & \texttt{float} & Numbers with decimal or fractional parts. \\
Boolean & \texttt{bool} & Represents logical truth values (true or false). \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Derived Data Types}

In addition to the primitive types above, the system specification also makes use of the following derived or composite types:

\begin{itemize}
    \item \textbf{Sequence:} An ordered collection of elements of the same data type. Example: A list of fragment identifiers or saved user sessions.
    \item \textbf{String:} A sequence of characters, typically used for textual input, labels, or metadata fields.
    \item \textbf{Tuple:} An ordered collection of values that may be of different data types. Commonly used to represent grouped entities such as \texttt{(FragmentId, ConfidenceScore)} or \texttt{(x, y, width, height)}.
    \item \textbf{Record / Object:} A structured type that groups named fields with defined data types, such as \texttt{\{id: FragmentId, script: String, confidence: Float\}}.
    \item \textbf{Function:} A mapping defined by the types of its inputs and outputs. Functions are specified by their type signatures (inputs/outputs) and behavior (preconditions, postconditions, and effects).
\end{itemize}

\subsection{Interface and Parameter Conventions}

This section explains how interfaces and operations are written in the MIS. The goal is to make them easy to read and understand while staying general enough to apply to any implementation.

\begin{itemize}
    \item \textbf{Inputs and Outputs:} Labeled as \texttt{in:} and \texttt{out:} in operation definitions. Example: \texttt{search(in: SearchQuery, out: SearchResult)}
    \item \textbf{Operation Format:} \texttt{functionName(in: InputType, out: OutputType) → may throw ErrorType}
    \item \textbf{Module Naming Convention:} Each module name follows the format \texttt{Layer.Module}, for example: \texttt{UI.Canvas}, \texttt{Svc.MatchOrch}, or \texttt{Data.FragmentStore}.
    \item \textbf{Boolean Conditions:} Represented using logical symbols such as $\land$ (and), $\lor$ (or), $\lnot$ (not), and $\implies$ (implies).
\end{itemize}


\section{Module Decomposition}



The following section summarizes the module hierarchy for the \textit{Sanskrit Manuscript Fragment Reconstruction Platform}. It is consistent with the \textbf{Module Guide (MG)} for this project and represents how the system has been decomposed into modules at different abstraction levels.

Each level in the hierarchy captures a different design concern:

\begin{itemize}
    \item \textbf{Hardware-Hiding Level:} Interfaces directly with the system’s physical or platform-dependent resources.
    \item \textbf{Behaviour-Hiding Level:} Encapsulates the main functional behavior of the system, implementing the use cases described in the SRS.
    \item \textbf{Software Decision Level:} Contains lower-level utility modules and software decisions that simplify implementation but are not visible to the user.
\end{itemize}

\subsection{Module Hierarchy}

\begin{table}[h!]
\centering
\caption{Module Hierarchy}
\small
\begin{tabular}{ll}
\toprule
\textbf{Level 1} & \textbf{Level 2 Modules} \\
\midrule
Hardware-Hiding (HW) & Image Storage Interface \\
\addlinespace
Behaviour-Hiding & 
\begin{minipage}[t]{0.7\linewidth}
\textbf{User Interface (UI):} \texttt{UI.Canvas}, \texttt{UI.Search}, \texttt{UI.Auth}, \texttt{UI.Upload}, \texttt{UI.SaveSession}, \texttt{UI.LoadSession}\\
\textbf{Service Layer (Svc):} \texttt{Svc.API}, \texttt{Svc.Search}, \texttt{Svc.AuthZ}, \texttt{Svc.Session}, \texttt{Svc.ProcOrch}, \texttt{Svc.MatchOrch}\\
\textbf{Data Management (Data):} \texttt{Data.FragmentStore}, \texttt{Data.Catalog}, \texttt{Data.User}, \texttt{Data.Project}\\
\textbf{Machine Learning Modules (ML):} \texttt{ML.EdgeMatch}, \texttt{ML.ScriptClass}, \texttt{ML.TextSim}, \texttt{ML.Segmentation}, \texttt{ML.CircleRecognition}, \texttt{ML.LineCount}, \texttt{ML.EdgeClassification}
\end{minipage} \\
\addlinespace
Software Decision & 
\begin{minipage}[t]{0.7\linewidth}
Utility and Support Modules (Error Handling, Logging, Configuration Management, Test Stubs)
\end{minipage} \\
\bottomrule
\end{tabular}
\end{table}

\newpage

\subsection{Description of Levels}

\subsubsection{Hardware-Hiding Level}
This level hides all hardware and platform dependencies from the rest of the system. It includes interfaces that communicate with the file storage system, image repositories, and cloud infrastructure. These components provide a uniform interface for accessing images and metadata regardless of the underlying storage medium.

\subsubsection{Behaviour-Hiding Level}
This level defines the functional behavior of the system, implementing the requirements outlined in the SRS. It includes the user-facing modules (UI), the application logic (Service Layer), data persistence (Data Layer), and intelligent processing (ML Layer). These modules interact through clearly defined service interfaces, promoting modularity and separation of concerns.

\subsubsection{Software Decision Level}
This level includes supporting components that are primarily design decisions rather than functional necessities. These modules include configuration handlers, utility libraries, and testing or logging frameworks that support development, debugging, and maintenance.


\section{MIS of HW.ImageStorage} \label{HW.ImageStorage}

\subsection{Module}
\textbf{HW.ImageStorage} \; (Image Storage Interface)

This module provides a uniform interface for reading, writing, and managing manuscript fragment image files and related metadata in the underlying file system or cloud storage. It hides all platform-specific file operations from higher-level modules and ensures consistent access and naming conventions.

\subsection{Uses}
\begin{itemize}
    \item \texttt{Data.FragmentStore} – for linking stored image references to fragment metadata records.
    \item \texttt{Svc.ProcOrch} – for initiating preprocessing or orientation correction workflows once an image is stored.
    \item External file system or object storage API.
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}
\begin{itemize}
    \item \texttt{MAX\_FILE\_SIZE = 50MB}
    \item \texttt{SUPPORTED\_FORMATS = \{.jpg, .png, .tiff\}}
    \item \texttt{STORAGE\_PATH = "/images/"}
\end{itemize}

\subsubsection{Exported Access Programs}

\begin{table}[H]
\centering
\small
\caption{HW.ImageStorage - Exported Access Programs}
\begin{tabular}{p{3cm} p{3.5cm} p{3cm} p{4.5cm}}
\toprule
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\midrule
\texttt{storeImage} & \texttt{file: ImageFile, metadata: Record} & \texttt{ImageID} & \texttt{InvalidFormatError, StorageWriteError} \\
\texttt{retrieveImage} & \texttt{id: ImageID} & \texttt{ImageFile} & \texttt{NotFoundError, StorageReadError} \\
\texttt{deleteImage} & \texttt{id: ImageID} & \texttt{bool} & \texttt{NotFoundError, StorageWriteError} \\
\texttt{getMetadata} & \texttt{id: ImageID} & \texttt{Record} & \texttt{NotFoundError} \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
    \item \texttt{storageIndex: Map[ImageID, FilePath]}
    \item \texttt{metadataCache: Map[ImageID, Record]}
\end{itemize}

\subsubsection{Environment Variables}
\begin{itemize}
    \item \texttt{FileSystem / CloudStorage} – external persistence for image binaries
\end{itemize}

\subsubsection{Assumptions}
\begin{itemize}
    \item The underlying storage service guarantees atomic read/write operations.
    \item ImageIDs are globally unique.
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent \texttt{storeImage(file, metadata)}:
\begin{itemize}
    \item transition: file is written to storage; \texttt{storageIndex} and \texttt{metadataCache} updated with new entry.
    \item output: a newly generated \texttt{ImageID}.
    \item exception: \texttt{InvalidFormatError} if file type not in \texttt{SUPPORTED\_FORMATS}; \texttt{StorageWriteError} if write fails.
\end{itemize}

\noindent \texttt{retrieveImage(id)}:
\begin{itemize}
    \item output: image file associated with \texttt{id}.
    \item exception: \texttt{NotFoundError} if \texttt{id} absent from \texttt{storageIndex}; \texttt{StorageReadError} if read fails.
\end{itemize}

\noindent \texttt{deleteImage(id)}:
\begin{itemize}
    \item transition: remove image file from storage; delete entries from \texttt{storageIndex} and \texttt{metadataCache}.
    \item output: \texttt{true} if deletion successful.
    \item exception: \texttt{NotFoundError} if \texttt{id} not present; \texttt{StorageWriteError} if deletion fails.
\end{itemize}

\noindent \texttt{getMetadata(id)}:
\begin{itemize}
    \item output: metadata record associated with \texttt{id}.
    \item exception: \texttt{NotFoundError} if no record exists.
\end{itemize}

\subsubsection{Local Functions}
\begin{itemize}
    \item \texttt{generateImageID(file: ImageFile): ImageID}
    \item \texttt{validateFormat(file: ImageFile): bool}
\end{itemize}



\section{MIS of UI.Auth} \label{UI.Auth}

\subsection{Module}
\textbf{UI.Auth} \; (Authentication Interface)

This module provides the browser-facing login and logout experience. It collects user credentials, displays relevant error messages, and forwards authentication requests to the backend service. It does not perform authentication logic itself.

\subsection{Uses}
\begin{itemize}
    \item \texttt{Svc.AuthZ} – for validating credentials and issuing session tokens.
    \item \texttt{Svc.Session} – for managing client-side session lifecycle.
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}
\begin{itemize}
    \item \texttt{MAX\_LOGIN\_ATTEMPTS = 5}
\end{itemize}

\subsubsection{Exported Access Programs}

\begin{table}[H]
\centering
\small
\caption{UI.Auth - Exported Access Programs}
\begin{tabular}{p{3.5cm} p{3.2cm} p{3.2cm} p{4.1cm}}
\toprule
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\midrule
\texttt{renderLoginForm} & \texttt{none} & \texttt{none} & \texttt{UIRenderError} \\
\texttt{submitCredentials} & \texttt{creds: UserCredentials} & \texttt{AuthResult} & \texttt{AuthError, NetworkError, InboxOverflowError} \\
\texttt{logoutUser} & \texttt{none} & \texttt{bool} & \texttt{NetworkError} \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
    \item \texttt{loginAttempts: int} – count of consecutive failed attempts in current session.
    \item \texttt{authErrorMessage: String} – message shown on failed login.
\end{itemize}

\subsubsection{Environment Variables}
\begin{itemize}
    \item Browser window and Document Object Model(DOM).
\end{itemize}

\subsubsection{Assumptions}
\begin{itemize}
    \item Network connectivity is available for requests to \texttt{Svc.AuthZ}.
    \item Password input is masked and handled securely by the browser.
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent \texttt{renderLoginForm()}:
\begin{itemize}
    \item transition: updates DOM to show login form, clears previous error message.
    \item output: none.
    \item exception: \texttt{UIRenderError} if DOM cannot be updated.
\end{itemize}

\noindent \texttt{submitCredentials(creds)}:
\begin{itemize}
    \item transition: sends credentials to \texttt{Svc.AuthZ}; updates \texttt{loginAttempts} and \texttt{authErrorMessage} based on response.
    \item output: \texttt{AuthResult} indicating success or failure.
    \item exception: \texttt{AuthError} if credentials rejected; \texttt{NetworkError} if backend unreachable.
\end{itemize}

\noindent \texttt{logoutUser()}:
\begin{itemize}
    \item transition: clears client-side session state and redirects to login view.
    \item output: \texttt{true} if logout succeeds.
    \item exception: \texttt{NetworkError} if logout call to backend fails.
\end{itemize}

\subsubsection{Local Functions}
\begin{itemize}
    \item \texttt{displayError(msg: String)} – updates UI error region.
    \item \texttt{resetForm()} – clears form fields.
\end{itemize}



\section{MIS of UI.Upload} \label{UI.Upload}

\subsection{Module}
\textbf{UI.Upload} \; (Fragment Upload Interface)

This module allows users to select, preview, and submit manuscript fragment images for processing. It performs basic client-side validation and delegates storage and preprocessing to backend services.

\subsection{Uses}
\begin{itemize}
    \item \texttt{Svc.API} – for upload endpoints.
    \item \texttt{HW.ImageStorage} – indirectly, via backend, for persistent image storage.
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}
\begin{itemize}
    \item \texttt{MAX\_FILES\_PER\_UPLOAD = 20}
\end{itemize}

\subsubsection{Exported Access Programs}

\begin{table}[H]
\centering
\small
\caption{UI.Upload - Exported Access Programs}
\begin{tabular}{p{3.5cm} p{4cm} p{2.8cm} p{3.7cm}}
\toprule
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\midrule
\texttt{renderUploadPanel} & \texttt{none} & \texttt{none} & \texttt{UIRenderError} \\
\texttt{selectFiles} & \texttt{files: Sequence[ImageFile]} & \texttt{none} & \texttt{ValidationError} \\
\texttt{submitUpload} & \texttt{none} & \texttt{UploadResult} & \texttt{NetworkError, UploadError} \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
    \item \texttt{pendingFiles: Sequence[ImageFile]}
    \item \texttt{uploadErrorMessage: String}
\end{itemize}

\subsubsection{Environment Variables}
\begin{itemize}
    \item Browser file picker and local file system access (sandboxed).
\end{itemize}

\subsubsection{Assumptions}
\begin{itemize}
    \item The browser enforces configured file size constraints on selection when possible.
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent \texttt{renderUploadPanel()}:
\begin{itemize}
    \item transition: renders the upload panel, including file input control and status indicators.
    \item output: none.
    \item exception: \texttt{UIRenderError} if DOM cannot be updated.
\end{itemize}

\noindent \texttt{selectFiles(files)}:
\begin{itemize}
    \item transition: validates file count and basic properties; if valid, stores them in \texttt{pendingFiles}.
    \item output: none.
    \item exception: \texttt{ValidationError} if any file exceeds size or format constraints.
\end{itemize}

\noindent \texttt{submitUpload()}:
\begin{itemize}
    \item transition: sends \texttt{pendingFiles} to backend via \texttt{Svc.API}; clears \texttt{pendingFiles} on success.
    \item output: \texttt{UploadResult} containing list of created fragment IDs.
    \item exception: \texttt{NetworkError} if request fails; \texttt{UploadError} if backend rejects the upload.
\end{itemize}

\subsubsection{Local Functions}
\begin{itemize}
    \item \texttt{validateFiles(files)} – checks count, format, and size bounds.
    \item \texttt{previewThumbnails()} – generates and displays thumbnails for selected files.
\end{itemize}



\section{MIS of UI.Canvas} \label{UI.Canvas}

\subsection{Module}
\textbf{UI.Canvas} \; (Interactive Fragment Workspace)

This module provides the interactive canvas where scholars can view, move, rotate, and arrange multiple fragments simultaneously. It displays match suggestions and visual overlays for edges, damage patterns, or text regions.

\subsection{Uses}
\begin{itemize}
    \item \texttt{Svc.MatchOrch} – for requesting match suggestions.
    \item \texttt{Svc.Session} – for loading and saving canvas layouts.
    \item \texttt{Svc.API} – for fetching fragment images and overlays.
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}
\begin{itemize}
    \item \texttt{MAX\_FRAGMENTS\_ON\_CANVAS = 50}
\end{itemize}

\subsubsection{Exported Access Programs}

\begin{table}[H]
\centering
\small
\caption{UI.Canvas - Exported Access Programs}
\begin{tabular}{p{3.3cm} p{3.8cm} p{2.8cm} p{4.1cm}}
\toprule
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\midrule
\texttt{renderCanvas} & \texttt{state: CanvasState} & \texttt{none} & \texttt{UIRenderError} \\
\texttt{placeFragment} & \texttt{id: FragmentID, position: Tuple} & \texttt{none} & \texttt{LayoutError} \\
\texttt{rotateFragment} & \texttt{id: FragmentID, angle: float} & \texttt{none} & \texttt{LayoutError} \\
\texttt{requestMatches} & \texttt{id: FragmentID} & \texttt{none} & \texttt{NetworkError} \\
\texttt{saveLayout} & \texttt{none} & \texttt{LayoutID} & \texttt{NetworkError} \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
    \item \texttt{currentState: CanvasState} – positions, rotations, and visibility for fragments.
    \item \texttt{selectedFragment: FragmentID or null}
    \item \texttt{activeMatchOverlay: MatchResultList}
\end{itemize}

\subsubsection{Environment Variables}
\begin{itemize}
    \item Browser rendering surface (HTML canvas or equivalent).
\end{itemize}

\subsubsection{Assumptions}
\begin{itemize}
    \item Device supports required rendering capabilities for zoom and pan.
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent \texttt{renderCanvas(state)}:
\begin{itemize}
    \item transition: updates the visual layout to match \texttt{state}.
    \item output: none.
    \item exception: \texttt{UIRenderError} if rendering fails.
\end{itemize}

\noindent \texttt{placeFragment(id, position)}:
\begin{itemize}
    \item transition: updates \texttt{currentState} with new position for \texttt{id}.
    \item output: none.
    \item exception: \texttt{LayoutError} if fragment exceeds bounds or limit exceeded.
\end{itemize}

\noindent \texttt{rotateFragment(id, angle)}:
\begin{itemize}
    \item transition: updates rotation of \texttt{id} in \texttt{currentState}.
    \item output: none.
    \item exception: \texttt{LayoutError} if rotation cannot be applied.
\end{itemize}

\noindent \texttt{requestMatches(id)}:
\begin{itemize}
    \item transition: sends match request to \texttt{Svc.MatchOrch}; updates \texttt{activeMatchOverlay} when response is received.
    \item output: none.
    \item exception: \texttt{NetworkError} if request fails.
\end{itemize}

\noindent \texttt{saveLayout()}:
\begin{itemize}
    \item transition: persists \texttt{currentState} via \texttt{Svc.Session}.
    \item output: a \texttt{LayoutID} for later retrieval.
    \item exception: \texttt{NetworkError} if persistence fails.
\end{itemize}

\subsubsection{Local Functions}
\begin{itemize}
    \item \texttt{snapToEdges(id)} – adjusts position so nearby edges align visually.
    \item \texttt{highlightMatches(id)} – visually emphasizes suggested neighbors.
\end{itemize}



\section{MIS of UI.Search} \label{UI.Search}

\subsection{Module}
\textbf{UI.Search} \; (Database Search and Exploration Interface)

This module provides the interface for querying the fragment database, filtering results, and viewing metadata. It supports search by script type, line count, fragment size, and other criteria.

\subsection{Uses}
\begin{itemize}
    \item \texttt{Svc.Search} – for executing search queries.
    \item \texttt{Svc.API} – for retrieving fragment summaries and export payloads.
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}
\begin{itemize}
    \item \texttt{RESULTS\_PAGE\_SIZE = 25}
\end{itemize}

\subsubsection{Exported Access Programs}

\begin{table}[H]
\centering
\small
\caption{UI.Search - Exported Access Programs}
\begin{tabular}{p{3.5cm} p{3.2cm} p{3.2cm} p{4.1cm}}
\toprule
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\midrule
\texttt{renderSearchPanel} & \texttt{none} & \texttt{none} & \texttt{UIRenderError} \\
\texttt{submitQuery} & \texttt{q: SearchQuery} & \texttt{none} & \texttt{ValidationError, NetworkError} \\
\texttt{nextPage} & \texttt{none} & \texttt{none} & \texttt{NetworkError} \\
\texttt{exportResults} & \texttt{format: ExportFormat} & \texttt{none} & \texttt{NetworkError, ExportError} \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
    \item \texttt{currentQuery: SearchQuery}
    \item \texttt{currentPage: int}
    \item \texttt{results: SearchResultPage}
\end{itemize}

\subsubsection{Environment Variables}
\begin{itemize}
    \item Browser viewport for displaying tables and filters.
\end{itemize}

\subsubsection{Assumptions}
\begin{itemize}
    \item Backend search service responds within acceptable time bounds defined in the SRS.
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent \texttt{renderSearchPanel()}:
\begin{itemize}
    \item transition: displays search form, filters, and an empty or last-used results view.
    \item output: none.
    \item exception: \texttt{UIRenderError} if rendering fails.
\end{itemize}

\noindent \texttt{submitQuery(q)}:
\begin{itemize}
    \item transition: validates query parameters; if valid, sends query to \texttt{Svc.Search} and updates \texttt{results} and \texttt{currentPage}.
    \item output: none.
    \item exception: \texttt{ValidationError} if query malformed; \texttt{NetworkError} if backend unreachable.
\end{itemize}

\noindent \texttt{nextPage()}:
\begin{itemize}
    \item transition: increments \texttt{currentPage} and requests next result page.
    \item output: none.
    \item exception: \texttt{NetworkError} if request fails.
\end{itemize}

\noindent \texttt{exportResults(format)}:
\begin{itemize}
    \item transition: sends export request for current query to backend.
    \item output: none at UI level; triggers file download in browser.
    \item exception: \texttt{NetworkError} if backend unreachable; \texttt{ExportError} if export fails.
\end{itemize}

\subsubsection{Local Functions}
\begin{itemize}
    \item \texttt{renderResultsTable(results)} – updates DOM table from latest \texttt{SearchResultPage}.
    \item \texttt{validateSearchQuery(q)} – checks filter ranges and required fields.
\end{itemize}



\section{MIS of UI.SaveSession} \label{UI.SaveSession}

\subsection{Module}
\textbf{UI.SaveSession} \; (Session Save Interface)

This module provides the user interface for saving the current workspace state, including fragment arrangements, annotations, and reconstruction progress. It allows users to name and persist their work for later retrieval.

\subsection{Uses}
\begin{itemize}
    \item \texttt{Svc.Session} – for persisting session data to backend storage.
    \item \texttt{UI.Canvas} – for retrieving current canvas state.
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}
\begin{itemize}
    \item \texttt{MAX\_SESSION\_NAME\_LENGTH = 100}
\end{itemize}

\subsubsection{Exported Access Programs}

\begin{table}[H]
\centering
\small
\caption{UI.SaveSession - Exported Access Programs}
\begin{tabular}{p{3.5cm} p{3.2cm} p{3.2cm} p{4.1cm}}
\toprule
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\midrule
\texttt{renderSaveDialog} & \texttt{none} & \texttt{none} & \texttt{UIRenderError} \\
\texttt{saveCurrentSession} & \texttt{name: String} & \texttt{SessionID} & \texttt{ValidationError, NetworkError} \\
\texttt{validateSessionName} & \texttt{name: String} & \texttt{bool} & \texttt{ValidationError} \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
    \item \texttt{sessionName: String}
    \item \texttt{saveInProgress: bool}
    \item \texttt{lastSavedID: SessionID or null}
\end{itemize}

\subsubsection{Environment Variables}
\begin{itemize}
    \item Browser DOM for dialog rendering.
\end{itemize}

\subsubsection{Assumptions}
\begin{itemize}
    \item User is authenticated and has valid session context.
    \item Canvas state is available and valid at time of save.
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent \texttt{renderSaveDialog()}:
\begin{itemize}
    \item transition: displays modal dialog with input field for session name and save button.
    \item output: none.
    \item exception: \texttt{UIRenderError} if dialog cannot be rendered.
\end{itemize}

\noindent \texttt{saveCurrentSession(name)}:
\begin{itemize}
    \item transition: validates session name; captures current canvas state from \texttt{UI.Canvas}; sends save request to \texttt{Svc.Session}; updates \texttt{lastSavedID} on success.
    \item output: \texttt{SessionID} assigned by backend.
    \item exception: \texttt{ValidationError} if name invalid; \texttt{NetworkError} if save fails.
\end{itemize}

\noindent \texttt{validateSessionName(name)}:
\begin{itemize}
    \item output: \texttt{true} if name meets length and character requirements.
    \item exception: \texttt{ValidationError} if name invalid.
\end{itemize}

\subsubsection{Local Functions}
\begin{itemize}
    \item \texttt{showSuccessMessage(id)} – displays confirmation with session ID.
    \item \texttt{closeDialog()} – closes save dialog and clears state.
\end{itemize}



\section{MIS of UI.LoadSession} \label{UI.LoadSession}

\subsection{Module}
\textbf{UI.LoadSession} \; (Session Load Interface)

This module provides the user interface for browsing, selecting, and loading previously saved workspace sessions. It displays session metadata and allows users to restore their reconstruction work.

\subsection{Uses}
\begin{itemize}
    \item \texttt{Svc.Session} – for retrieving available sessions and loading session data.
    \item \texttt{UI.Canvas} – for applying loaded state to the canvas.
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}
\begin{itemize}
    \item \texttt{SESSIONS\_PAGE\_SIZE = 10}
\end{itemize}

\subsubsection{Exported Access Programs}

\begin{table}[H]
\centering
\small
\caption{UI.LoadSession - Exported Access Programs}
\begin{tabular}{p{3.5cm} p{3.2cm} p{3.2cm} p{4.1cm}}
\toprule
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\midrule
\texttt{renderLoadDialog} & \texttt{none} & \texttt{none} & \texttt{UIRenderError} \\
\texttt{fetchSessionList} & \texttt{none} & \texttt{SessionList} & \texttt{NetworkError} \\
\texttt{loadSession} & \texttt{id: SessionID} & \texttt{none} & \texttt{NotFoundError, NetworkError} \\
\texttt{deleteSession} & \texttt{id: SessionID} & \texttt{bool} & \texttt{NetworkError} \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
    \item \texttt{availableSessions: SessionList}
    \item \texttt{selectedSessionID: SessionID or null}
    \item \texttt{loadInProgress: bool}
\end{itemize}

\subsubsection{Environment Variables}
\begin{itemize}
    \item Browser DOM for dialog rendering and session list display.
\end{itemize}

\subsubsection{Assumptions}
\begin{itemize}
    \item User is authenticated and has valid session context.
    \item Session data retrieved from backend is valid and compatible with current system version.
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent \texttt{renderLoadDialog()}:
\begin{itemize}
    \item transition: displays modal dialog with list of saved sessions and load button.
    \item output: none.
    \item exception: \texttt{UIRenderError} if dialog cannot be rendered.
\end{itemize}

\noindent \texttt{fetchSessionList()}:
\begin{itemize}
    \item transition: requests list of available sessions from \texttt{Svc.Session}; updates \texttt{availableSessions}.
    \item output: \texttt{SessionList} containing session metadata (ID, name, date, preview).
    \item exception: \texttt{NetworkError} if request fails.
\end{itemize}

\noindent \texttt{loadSession(id)}:
\begin{itemize}
    \item transition: retrieves session data from \texttt{Svc.Session}; applies state to \texttt{UI.Canvas}; closes load dialog.
    \item output: none.
    \item exception: \texttt{NotFoundError} if session does not exist; \texttt{NetworkError} if retrieval fails.
\end{itemize}

\noindent \texttt{deleteSession(id)}:
\begin{itemize}
    \item transition: sends delete request to \texttt{Svc.Session}; removes session from \texttt{availableSessions} on success.
    \item output: \texttt{true} if deletion successful.
    \item exception: \texttt{NetworkError} if deletion fails.
\end{itemize}

\subsubsection{Local Functions}
\begin{itemize}
    \item \texttt{renderSessionList()} – updates DOM with session list.
    \item \texttt{confirmDelete(id)} – shows confirmation dialog before deletion.
    \item \texttt{closeDialog()} – closes load dialog and clears state.
\end{itemize}

\section{MIS of Svc.API} \label{Svc.API}

\subsection{Module}
\textbf{Svc.API} \; (Backend API Gateway)

This module exposes the backend functionality of the Sanskrit Manuscript Fragment Reconstruction Platform as a REST-style service layer. It routes incoming HTTP requests from the UI to the corresponding internal services, enforces basic request validation, and standardizes API responses.

\subsection{Uses}
\begin{itemize}
    \item \texttt{Svc.AuthZ} – for authentication and authorization checks.
    \item \texttt{Svc.Session} – for resolving current user/session context.
    \item \texttt{Svc.ProcOrch} – for preprocessing and normalization requests.
    \item \texttt{Svc.MatchOrch} – for fragment match discovery.
    \item \texttt{Svc.Search} – for database search and exploration.
    \item \texttt{Data.FragmentStore}, \texttt{Data.User}, \texttt{Data.Project}.
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}
\begin{itemize}
    \item \texttt{API\_VERSION = "v1"}
    \item \texttt{MAX\_REQUEST\_SIZE} – logical upper bound on payload size (aligned with SRS).
\end{itemize}

\subsubsection{Exported Access Programs}

\begin{table}[H]
\centering
\small
\caption{Svc.API - Exported Access Programs}
\begin{tabular}{p{4cm} p{2.9cm} p{2.9cm} p{4.2cm}}
\toprule
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\midrule
\texttt{handleAuthRequest} & \texttt{req: HttpRequest} & \texttt{HttpResponse} & \texttt{AuthError} \\
\texttt{handleUploadRequest} & \texttt{req: HttpRequest} & \texttt{HttpResponse} & \texttt{ValidationError, ServiceError} \\
\texttt{handleMatchRequest} & \texttt{req: HttpRequest} & \texttt{HttpResponse} & \texttt{ServiceError} \\
\texttt{handleSearchRequest} & \texttt{req: HttpRequest} & \texttt{HttpResponse} & \texttt{ValidationError, ServiceError} \\
\texttt{handleSessionRequest} & \texttt{req: HttpRequest} & \texttt{HttpResponse} & \texttt{ServiceError} \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
    \item \texttt{routeTable: Map[Endpoint, Handler]} – mapping between URL paths and internal handlers.
\end{itemize}

\subsubsection{Environment Variables}
\begin{itemize}
    \item HTTP server environment providing incoming requests and outgoing responses.
\end{itemize}

\subsubsection{Assumptions}
\begin{itemize}
    \item All requests include sufficient information to resolve user/session context when required.
    \item Lower-level services enforce their own invariants in addition to basic checks at this layer.
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent \texttt{handleAuthRequest(req)}:
\begin{itemize}
    \item transition: forwards credentials/token to \texttt{Svc.AuthZ}; logs outcome.
    \item output: \texttt{HttpResponse} with status code and (if successful) session token or user info.
    \item exception: \texttt{AuthError} if authentication fails or token invalid.
\end{itemize}

\noindent \texttt{handleUploadRequest(req)}:
\begin{itemize}
    \item transition: validates payload size and type; forwards work to \texttt{Svc.ProcOrch} for ingestion.
    \item output: \texttt{HttpResponse} including created fragment IDs or error details.
    \item exception: \texttt{ValidationError} if request violates constraints; \texttt{ServiceError} if downstream failure occurs.
\end{itemize}

\noindent \texttt{handleMatchRequest(req)}:
\begin{itemize}
    \item transition: parses fragment identifier and forwards to \texttt{Svc.MatchOrch}.
    \item output: \texttt{HttpResponse} containing ranked match suggestions.
    \item exception: \texttt{ServiceError} if orchestrator fails or times out.
\end{itemize}

\noindent \texttt{handleSearchRequest(req)}:
\begin{itemize}
    \item transition: validates search query parameters; forwards to \texttt{Svc.Search}.
    \item output: \texttt{HttpResponse} containing search results page.
    \item exception: \texttt{ValidationError} for malformed queries; \texttt{ServiceError} on backend failures.
\end{itemize}

\noindent \texttt{handleSessionRequest(req)}:
\begin{itemize}
    \item transition: routes session save/load actions to \texttt{Svc.Session}.
    \item output: \texttt{HttpResponse} with session payload or confirmation.
    \item exception: \texttt{ServiceError} if the session operation fails.
\end{itemize}

\subsubsection{Local Functions}
\begin{itemize}
    \item \texttt{parseJSONBody(req)} – extracts and validates JSON payload.
    \item \texttt{buildErrorResponse(code, msg)} – standardizes error responses.
\end{itemize}

\section{MIS of Svc.AuthZ} \label{Svc.AuthZ}

\subsection{Module}
\textbf{Svc.AuthZ} \; (Authentication and Authorization Service)

This module validates user credentials, issues and verifies session tokens, and enforces access control for protected operations.

\subsection{Uses}
\begin{itemize}
    \item \texttt{Data.User} – for user credentials and role lookup.
    \item Cryptographic utilities (hashing, token signing).
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}
\begin{itemize}
    \item \texttt{TOKEN\_TTL\_MINUTES} – session token lifetime.
    \item \texttt{MAX\_FAILED\_ATTEMPTS} – lockout threshold.
\end{itemize}

\subsubsection{Exported Access Programs}

\begin{table}[H]
\centering
\small
\caption{Svc.AuthZ - Exported Access Programs}
\begin{tabular}{p{3.2cm} p{3.8cm} p{3cm} p{4cm}}
\toprule
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\midrule
\texttt{authenticate} & \texttt{creds: UserCredentials} & \texttt{AuthResult} & \texttt{AuthError} \\
\texttt{validateToken} & \texttt{token: String} & \texttt{UserContext} & \texttt{AuthError} \\
\texttt{checkAccess} & \texttt{ctx: UserContext, action: String} & \texttt{bool} & \texttt{AuthError} \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
    \item \texttt{failedAttempts: Map[UserID, int]}
\end{itemize}

\subsubsection{Environment Variables}
\begin{itemize}
    \item Secure storage for password hashes and secret keys.
\end{itemize}

\subsubsection{Assumptions}
\begin{itemize}
    \item Passwords are stored as salted hashes only.
    \item Time and randomness sources are trustworthy for token generation.
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent \texttt{authenticate(creds)}:
\begin{itemize}
    \item transition: verifies credentials against stored hash; updates \texttt{failedAttempts}.
    \item output: \texttt{AuthResult} containing success flag and token on success.
    \item exception: \texttt{AuthError} if user locked out or credentials invalid.
\end{itemize}

\noindent \texttt{validateToken(token)}:
\begin{itemize}
    \item output: \texttt{UserContext} if token valid and not expired.
    \item exception: \texttt{AuthError} if token invalid or expired.
\end{itemize}

\noindent \texttt{checkAccess(ctx, action)}:
\begin{itemize}
    \item output: \texttt{true} if user role in \texttt{ctx} is allowed to perform \texttt{action}.
    \item exception: \texttt{AuthError} if context invalid.
\end{itemize}

\subsubsection{Local Functions}
\begin{itemize}
    \item \texttt{hashPassword(pw)} – hashes password for comparison.
    \item \texttt{generateToken(user)} – constructs signed token.
\end{itemize}



\section{MIS of Svc.Session} \label{Svc.Session}

\subsection{Module}
\textbf{Svc.Session} \; (Session and Workspace Management Service)

This module manages user sessions, saved canvas layouts, and ongoing reconstruction projects. It provides persistent storage and retrieval of user workspace state.

\subsection{Uses}
\begin{itemize}
    \item \texttt{Data.Project} – for project-level data and references.
    \item \texttt{Data.User} – for associating sessions with users.
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}
\begin{itemize}
    \item \texttt{MAX\_SAVED\_LAYOUTS\_PER\_USER}
\end{itemize}

\subsubsection{Exported Access Programs}

\begin{table}[H]
\centering
\small
\caption{Svc.Session - Exported Access Programs}
\begin{tabular}{p{3.3cm} p{3cm} p{4.8cm} p{3.9cm}}
\toprule
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\midrule
\texttt{saveCanvasState} & \texttt{ctx: UserContext, state: CanvasState} & \texttt{LayoutID} & \texttt{SessionError} \\
\texttt{loadCanvasState} & \texttt{ctx: UserContext, id: LayoutID} & \texttt{CanvasState} & \texttt{NotFoundError, SessionError} \\
\texttt{listLayouts} & \texttt{ctx: UserContext} & \texttt{Sequence[LayoutSummary]} & \texttt{SessionError} \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
    \item \texttt{layoutStore: Map[LayoutID, (UserID, CanvasState)]}
\end{itemize}

\subsubsection{Environment Variables}
\begin{itemize}
    \item Persistent database for layouts and project metadata.
\end{itemize}

\subsubsection{Assumptions}
\begin{itemize}
    \item \texttt{UserContext} is valid and has been authenticated by \texttt{Svc.AuthZ}.
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent \texttt{saveCanvasState(ctx, state)}:
\begin{itemize}
    \item transition: creates or updates an entry in \texttt{layoutStore} for the user.
    \item output: generated \texttt{LayoutID}.
    \item exception: \texttt{SessionError} if write fails or limit exceeded.
\end{itemize}

\noindent \texttt{loadCanvasState(ctx, id)}:
\begin{itemize}
    \item output: \texttt{CanvasState} associated with user and layout ID.
    \item exception: \texttt{NotFoundError} if layout does not exist or not owned by user; \texttt{SessionError} on read failure.
\end{itemize}

\noindent \texttt{listLayouts(ctx)}:
\begin{itemize}
    \item output: summaries of layouts owned by the user.
    \item exception: \texttt{SessionError} if retrieval fails.
\end{itemize}

\subsubsection{Local Functions}
\begin{itemize}
    \item \texttt{generateLayoutID()} – creates unique identifier for layouts.
\end{itemize}



\section{MIS of Svc.ProcOrch} \label{Svc.ProcOrch}

\subsection{Module}
\textbf{Svc.ProcOrch} \; (Preprocessing and Normalization Orchestrator)

This module coordinates image preprocessing workflows such as orientation correction, denoising, and resolution standardization before downstream analysis.

\subsection{Uses}
\begin{itemize}
    \item \texttt{HW.ImageStorage} – for reading and writing image files.
    \item \texttt{ML.EdgeMatch}, \texttt{ML.Damage} – where preprocessing parameters are shared.
    \item External image processing library (for example, OpenCV).
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}
\begin{itemize}
    \item \texttt{TARGET\_RESOLUTION} – canonical resolution for normalized images.
    \item \texttt{MAX\_ORIENTATION\_ERROR} – tolerated post-correction skew.
\end{itemize}

\subsubsection{Exported Access Programs}

\begin{table}[H]
\centering
\small
\caption{Svc.ProcOrch - Exported Access Programs}
\begin{tabular}{p{4cm} p{3cm} p{3.5cm} p{3.5cm}}
\toprule
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\midrule
\texttt{enqueuePreprocessing} & \texttt{id: ImageID} & \texttt{JobID} & \texttt{PreprocError} \\
\texttt{runPreprocessing} & \texttt{job: JobID} & \texttt{PreprocResult} & \texttt{PreprocError} \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
    \item \texttt{jobQueue: Sequence[JobID]}
\end{itemize}

\subsubsection{Environment Variables}
\begin{itemize}
    \item Execution environment for batch or async jobs.
\end{itemize}

\subsubsection{Assumptions}
\begin{itemize}
    \item Input image already stored by \texttt{HW.ImageStorage}.
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent \texttt{enqueuePreprocessing(id)}:
\begin{itemize}
    \item transition: creates a preprocessing job for \texttt{id} and appends it to \texttt{jobQueue}.
    \item output: \texttt{JobID} for tracking.
    \item exception: \texttt{PreprocError} if job cannot be created.
\end{itemize}

\noindent \texttt{runPreprocessing(job)}:
\begin{itemize}
    \item transition: retrieves image by \texttt{ImageID}, applies normalization steps, and writes results back to storage.
    \item output: \texttt{PreprocResult} containing normalized image reference and metrics (for example, estimated orientation error).
    \item exception: \texttt{PreprocError} if any step fails.
\end{itemize}

\subsubsection{Local Functions}
\begin{itemize}
    \item \texttt{correctOrientation(img)} – aligns text horizontally.
    \item \texttt{normalizeResolution(img)} – resamples to \texttt{TARGET\_RESOLUTION}.
\end{itemize}



\section{MIS of Svc.MatchOrch} \label{Svc.MatchOrch}

\subsection{Module}
\textbf{Svc.MatchOrch} \; (Fragment Matching Orchestrator)

This module coordinates AI models for fragment matching, aggregates model outputs, and produces ranked match suggestions for a given fragment.

\subsection{Uses}
\begin{itemize}
    \item \texttt{ML.EdgeMatch}, \texttt{ML.Damage}, \texttt{ML.TextSim}.
    \item \texttt{Data.FragmentStore} – for retrieving fragment metadata.
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}
\begin{itemize}
    \item \texttt{MAX\_TOP\_MATCHES = 10}
    \item \texttt{MATCH\_CONFIDENCE\_THRESHOLD = 0.6}
\end{itemize}

\subsubsection{Exported Access Programs}

\begin{table}[H]
\centering
\small
\caption{Svc.MatchOrch - Exported Access Programs}
\begin{tabular}{p{3.5cm} p{4.5cm} p{2.5cm} p{3.5cm}}
\toprule
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\midrule
\texttt{generateMatches} & \texttt{frag: FragmentID} & \texttt{MatchResultList} & \texttt{MatchError} \\
\texttt{aggregateScores} & \texttt{scores: Sequence[ModelScore]} & \texttt{float} & \texttt{AggregationError} \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
    \item \texttt{recentResults: Map[FragmentID, MatchResultList]}
\end{itemize}

\subsubsection{Environment Variables}
\begin{itemize}
    \item ML model serving endpoints.
\end{itemize}

\subsubsection{Assumptions}
\begin{itemize}
    \item Each model returns normalized scores in \([0, 1]\).
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent \texttt{generateMatches(frag)}:
\begin{itemize}
    \item transition: queries all relevant ML models; aggregates and sorts candidate matches; updates \texttt{recentResults}.
    \item output: \texttt{MatchResultList} of top candidates above threshold.
    \item exception: \texttt{MatchError} if models unavailable or response invalid.
\end{itemize}

\noindent \texttt{aggregateScores(scores)}:
\begin{itemize}
    \item output: combined score (for example, weighted mean) over model scores.
    \item exception: \texttt{AggregationError} if sequence empty or weights invalid.
\end{itemize}

\subsubsection{Local Functions}
\begin{itemize}
    \item \texttt{filterByThreshold(results)} – drops candidates below \texttt{MATCH\_CONFIDENCE\_THRESHOLD}.
    \item \texttt{sortByScore(results)} – orders candidates descending by final score.
\end{itemize}



\section{MIS of Svc.Search} \label{Svc.Search}

\subsection{Module}
\textbf{Svc.Search} \; (Search and Exploration Service)

This module executes queries over stored fragments and metadata, providing paginated and filterable search results to the UI.

\subsection{Uses}
\begin{itemize}
    \item \texttt{Data.FragmentStore}, \texttt{Data.Catalog}.
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}
\begin{itemize}
    \item \texttt{DEFAULT\_PAGE\_SIZE = 25}
\end{itemize}

\subsubsection{Exported Access Programs}

\begin{table}[H]
\centering
\small
\caption{Svc.Search - Exported Access Programs}
\begin{tabular}{p{3.5cm} p{4cm} p{3.2cm} p{4.3cm}}
\toprule
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\midrule
\texttt{executeQuery} & \texttt{q: SearchQuery, page: int} & \texttt{SearchResultPage} & \texttt{SearchError} \\
\texttt{exportResults} & \texttt{q: SearchQuery, format: ExportFormat} & \texttt{ExportPayload} & \texttt{SearchError, ExportError} \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
    \item none
\end{itemize}

\subsubsection{Environment Variables}
\begin{itemize}
    \item Database engine for indexing and querying fragment records.
\end{itemize}

\subsubsection{Assumptions}
\begin{itemize}
    \item All searchable fields are indexed appropriately for performance.
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent \texttt{executeQuery(q, page)}:
\begin{itemize}
    \item output: \texttt{SearchResultPage} containing fragment summaries for the requested page.
    \item exception: \texttt{SearchError} if query invalid or backend failure occurs.
\end{itemize}

\noindent \texttt{exportResults(q, format)}:
\begin{itemize}
    \item output: \texttt{ExportPayload} that can be streamed to client as CSV or PDF.
    \item exception: \texttt{SearchError} on query failure; \texttt{ExportError} if export generation fails.
\end{itemize}

\subsubsection{Local Functions}
\begin{itemize}
    \item \texttt{buildQueryPlan(q)} – compiles filter and sort options into database query.
    \item \texttt{formatExport(results, format)} – converts results into specified output format.
\end{itemize}

%===========================
% DATA MANAGEMENT MODULES
%===========================

\section{MIS of Data.FragmentStore} \label{Data.FragmentStore}

\subsection{Module}
\textbf{Data.FragmentStore} \; (Fragment Metadata Store)

This module is responsible for storing and retrieving logical fragment entities. It maintains metadata such as fragment IDs, associated image IDs, script labels, line counts, and status flags, and acts as the core record of fragments used throughout the system.

\subsection{Uses}
\begin{itemize}
    \item \texttt{HW.ImageStorage} – via stored \texttt{ImageID} references.
    \item \texttt{Data.Catalog} – for linking to external catalogue identifiers when available.
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}
\begin{itemize}
    \item \texttt{MAX\_LABEL\_LENGTH}
\end{itemize}

\subsubsection{Exported Access Programs}

\begin{table}[H]
\centering
\small
\caption{Data.FragmentStore - Exported Access Programs}
\begin{tabular}{p{3.2cm} p{3.8cm} p{3cm} p{4cm}}
\toprule
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\midrule
\texttt{createFragment} & \texttt{rec: FragmentRecord} & \texttt{FragmentID} & \texttt{FragmentError} \\
\texttt{getFragment} & \texttt{id: FragmentID} & \texttt{FragmentRecord} & \texttt{NotFoundError} \\
\texttt{updateFragment} & \texttt{id: FragmentID, rec: FragmentRecord} & \texttt{bool} & \texttt{FragmentError, NotFoundError} \\
\texttt{deleteFragment} & \texttt{id: FragmentID} & \texttt{bool} & \texttt{FragmentError, NotFoundError} \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
    \item \texttt{fragmentTable: Map[FragmentID, FragmentRecord]}
\end{itemize}

\subsubsection{Environment Variables}
\begin{itemize}
    \item Relational database or equivalent persistent storage.
\end{itemize}

\subsubsection{Assumptions}
\begin{itemize}
    \item Fragment IDs are globally unique and stable over time.
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent \texttt{createFragment(rec)}:
\begin{itemize}
    \item transition: inserts a new record into \texttt{fragmentTable}.
    \item output: new \texttt{FragmentID}.
    \item exception: \texttt{FragmentError} if insert fails or constraints violated.
\end{itemize}

\noindent \texttt{getFragment(id)}:
\begin{itemize}
    \item output: record associated with \texttt{id}.
    \item exception: \texttt{NotFoundError} if no record exists.
\end{itemize}

\noindent \texttt{updateFragment(id, rec)}:
\begin{itemize}
    \item transition: replaces existing record for \texttt{id} with \texttt{rec}.
    \item output: \texttt{true} if update successful.
    \item exception: \texttt{NotFoundError} if \texttt{id} unknown; \texttt{FragmentError} on write failure.
\end{itemize}

\noindent \texttt{deleteFragment(id)}:
\begin{itemize}
    \item transition: removes record associated with \texttt{id}.
    \item output: \texttt{true} if deletion successful.
    \item exception: \texttt{NotFoundError} if \texttt{id} unknown; \texttt{FragmentError} on delete failure.
\end{itemize}

\subsubsection{Local Functions}
\begin{itemize}
    \item \texttt{validateFragment(rec)} – checks required fields and constraints.
\end{itemize}



\section{MIS of Data.Catalog} \label{Data.Catalog}

\subsection{Module}
\textbf{Data.Catalog} \; (External Catalogue Link Store)

This module maintains mappings between internal fragments and external catalogue identifiers from libraries, collections, or previous editions.

\subsection{Uses}
\begin{itemize}
    \item \texttt{Data.FragmentStore} – for core fragment records.
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}
\begin{itemize}
    \item \texttt{MAX\_CATALOG\_ID\_LENGTH}
\end{itemize}

\subsubsection{Exported Access Programs}

\begin{table}[H]
\centering
\small
\caption{Data.Catalog - Exported Access Programs}
\begin{tabular}{p{4.2cm} p{3.8cm} p{3.5cm} p{2.5cm}}
\toprule
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\midrule
\texttt{linkFragmentToCatalog} & \texttt{frag: FragmentID, catID: String} & \texttt{bool} & \texttt{CatalogError} \\
\texttt{getCatalogIDs} & \texttt{frag: FragmentID} & \texttt{Sequence[String]} & \texttt{CatalogError} \\
\texttt{findByCatalogID} & \texttt{catID: String} & \texttt{Sequence[FragmentID]} & \texttt{CatalogError} \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
    \item \texttt{catalogMap: Map[FragmentID, Sequence[String]]}
\end{itemize}

\subsubsection{Environment Variables}
\begin{itemize}
    \item Same underlying database as the fragment store or a logically related schema.
\end{itemize}

\subsubsection{Assumptions}
\begin{itemize}
    \item External catalogue identifiers are opaque strings; uniqueness is handled externally.
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent \texttt{linkFragmentToCatalog(frag, catID)}:
\begin{itemize}
    \item transition: appends \texttt{catID} to the list of identifiers for \texttt{frag}.
    \item output: \texttt{true} on success.
    \item exception: \texttt{CatalogError} on write failure.
\end{itemize}

\noindent \texttt{getCatalogIDs(frag)}:
\begin{itemize}
    \item output: all catalogue IDs associated with \texttt{frag}.
    \item exception: \texttt{CatalogError} if retrieval fails.
\end{itemize}

\noindent \texttt{findByCatalogID(catID)}:
\begin{itemize}
    \item output: all \texttt{FragmentID} values linked to \texttt{catID}.
    \item exception: \texttt{CatalogError} if query fails.
\end{itemize}

\subsubsection{Local Functions}
\begin{itemize}
    \item \texttt{normalizeCatalogID(catID)} – optional normalization (trim, case).
\end{itemize}



\section{MIS of Data.User} \label{Data.User}

\subsection{Module}
\textbf{Data.User} \; (User Account Store)

This module stores user accounts, credentials (hashed), roles, and profile information required for authentication and access control.

\subsection{Uses}
\begin{itemize}
    \item Cryptographic utilities for password hashing.
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}
\begin{itemize}
    \item \texttt{MAX\_USERNAME\_LENGTH}
    \item \texttt{MAX\_EMAIL\_LENGTH}
\end{itemize}

\subsubsection{Exported Access Programs}

\begin{table}[H]
\centering
\small
\caption{Data.User - Exported Access Programs}
\begin{tabular}{p{3.3cm} p{3.5cm} p{3.2cm} p{4cm}}
\toprule
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\midrule
\texttt{createUser} & \texttt{rec: UserRecord} & \texttt{UserID} & \texttt{UserError} \\
\texttt{getUserByID} & \texttt{id: UserID} & \texttt{UserRecord} & \texttt{NotFoundError} \\
\texttt{getUserByEmail} & \texttt{email: String} & \texttt{UserRecord} & \texttt{NotFoundError} \\
\texttt{updateUser} & \texttt{id: UserID, rec: UserRecord} & \texttt{bool} & \texttt{UserError, NotFoundError} \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
    \item \texttt{userTable: Map[UserID, UserRecord]}
\end{itemize}

\subsubsection{Environment Variables}
\begin{itemize}
    \item Persistent user database with appropriate access controls.
\end{itemize}

\subsubsection{Assumptions}
\begin{itemize}
    \item Email addresses are unique per user.
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent \texttt{createUser(rec)}:
\begin{itemize}
    \item transition: inserts new user record; hashes password fields before storage.
    \item output: generated \texttt{UserID}.
    \item exception: \texttt{UserError} if constraints violated or write fails.
\end{itemize}

\noindent \texttt{getUserByID(id)}:
\begin{itemize}
    \item output: user record with \texttt{id}.
    \item exception: \texttt{NotFoundError} if no such user.
\end{itemize}

\noindent \texttt{getUserByEmail(email)}:
\begin{itemize}
    \item output: user record whose email matches \texttt{email}.
    \item exception: \texttt{NotFoundError} if not found.
\end{itemize}

\noindent \texttt{updateUser(id, rec)}:
\begin{itemize}
    \item transition: updates record for \texttt{id}.
    \item output: \texttt{true} on success.
    \item exception: \texttt{NotFoundError} if \texttt{id} unknown; \texttt{UserError} on failure.
\end{itemize}

\subsubsection{Local Functions}
\begin{itemize}
    \item \texttt{validateUser(rec)} – checks email format, password policy etc.
\end{itemize}



\section{MIS of Data.Project} \label{Data.Project}

\subsection{Module}
\textbf{Data.Project} \; (Project and Reconstruction Session Store)

This module records reconstruction projects, including project metadata, associated fragments, and saved reconstruction sessions.

\subsection{Uses}
\begin{itemize}
    \item \texttt{Data.User} – to associate projects with owners or collaborators.
    \item \texttt{Data.FragmentStore}.
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}
\begin{itemize}
    \item \texttt{MAX\_PROJECT\_NAME\_LENGTH}
\end{itemize}

\subsubsection{Exported Access Programs}

\begin{table}[H]
\centering
\small
\caption{Data.Project - Exported Access Programs}
\begin{tabular}{p{3.8cm} p{3.2cm} p{4.5cm} p{2.5cm}}
\toprule
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\midrule
\texttt{createProject} & \texttt{rec: ProjectRecord} & \texttt{ProjectID} & \texttt{ProjectError} \\
\texttt{getProject} & \texttt{id: ProjectID} & \texttt{ProjectRecord} & \texttt{NotFoundError} \\
\texttt{updateProject} & \texttt{id: ProjectID, rec: ProjectRecord} & \texttt{bool} & \texttt{ProjectError, NotFoundError} \\
\texttt{listProjectsForUser} & \texttt{user: UserID} & \texttt{Sequence[ProjectSummary]} & \texttt{ProjectError} \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
    \item \texttt{projectTable: Map[ProjectID, ProjectRecord]}
\end{itemize}

\subsubsection{Environment Variables}
\begin{itemize}
    \item Persistent project database.
\end{itemize}

\subsubsection{Assumptions}
\begin{itemize}
    \item Each project belongs to at least one user.
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent \texttt{createProject(rec)}:
\begin{itemize}
    \item transition: inserts new row in \texttt{projectTable}.
    \item output: created \texttt{ProjectID}.
    \item exception: \texttt{ProjectError} on constraint violation or failure.
\end{itemize}

\noindent \texttt{getProject(id)}:
\begin{itemize}
    \item output: project record matching \texttt{id}.
    \item exception: \texttt{NotFoundError} if none exists.
\end{itemize}

\noindent \texttt{updateProject(id, rec)}:
\begin{itemize}
    \item transition: updates stored record.
    \item output: \texttt{true} on success.
    \item exception: \texttt{NotFoundError} or \texttt{ProjectError}.
\end{itemize}

\noindent \texttt{listProjectsForUser(user)}:
\begin{itemize}
    \item output: summaries of all projects owned by or shared with \texttt{user}.
    \item exception: \texttt{ProjectError} if query fails.
\end{itemize}

\subsubsection{Local Functions}
\begin{itemize}
    \item \texttt{validateProject(rec)} – checks required fields and name length.
\end{itemize}



%===========================
% MACHINE LEARNING MODULES
%===========================

\section{MIS of ML.EdgeMatch} \label{ML.EdgeMatch}

\subsection{Module}
\textbf{ML.EdgeMatch} \; (Edge Pattern Matching Model)

This module provides model-based similarity estimates based on fragment edge contours and shapes.

\subsection{Uses}
\begin{itemize}
    \item \texttt{HW.ImageStorage} – to retrieve normalized images.
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}
\begin{itemize}
    \item \texttt{EDGE\_SIGNATURE\_DIM}
\end{itemize}

\subsubsection{Exported Access Programs}

\begin{table}[H]
\centering
\small
\caption{ML.EdgeMatch - Exported Access Programs}
\begin{tabular}{p{4cm} p{4.5cm} p{2.3cm} p{3.2cm}}
\toprule
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\midrule
\texttt{computeEdgeSignature} & \texttt{id: ImageID} & \texttt{EdgeSignature} & \texttt{ModelError} \\
\texttt{scoreEdgeSimilarity} & \texttt{a: EdgeSignature, b: EdgeSignature} & \texttt{float} & \texttt{ModelError} \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
    \item Optional cached model weights and configuration.
\end{itemize}

\subsubsection{Environment Variables}
\begin{itemize}
    \item Model runtime (for example, PyTorch or TensorFlow backend).
\end{itemize}

\subsubsection{Assumptions}
\begin{itemize}
    \item Input images have been preprocessed and normalized by \texttt{Svc.ProcOrch}.
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent \texttt{computeEdgeSignature(id)}:
\begin{itemize}
    \item output: fixed-length vector representing edge features for the image.
    \item exception: \texttt{ModelError} if image cannot be processed.
\end{itemize}

\noindent \texttt{scoreEdgeSimilarity(a, b)}:
\begin{itemize}
    \item output: similarity score in \([0, 1]\) reflecting how well edges match.
    \item exception: \texttt{ModelError} if signatures invalid or incompatible.
\end{itemize}

\subsubsection{Local Functions}
\begin{itemize}
    \item \texttt{extractContours(img)} – local function to compute edge features.
\end{itemize}



\section{MIS of ML.ScriptClass} \label{ML.ScriptClass}

\subsection{Module}
\textbf{ML.ScriptClass} \; (Script Classification Model)

This module classifies the script type of a fragment (for example, Gupta Brāhmī, Tibetan Uchen, Chinese) and returns confidence scores.

\subsection{Uses}
\begin{itemize}
    \item \texttt{HW.ImageStorage}.
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}
\begin{itemize}
    \item \texttt{SUPPORTED\_SCRIPTS: Sequence[String]}
\end{itemize}

\subsubsection{Exported Access Programs}

\begin{table}[H]
\centering
\small
\caption{ML.ScriptClass - Exported Access Programs}
\begin{tabular}{p{3.5cm} p{3.5cm} p{3.5cm} p{3.5cm}}
\toprule
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\midrule
\texttt{classifyScript} & \texttt{id: ImageID} & \texttt{ScriptPrediction} & \texttt{ModelError} \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
    \item Model weights for script classification.
\end{itemize}

\subsubsection{Environment Variables}
\begin{itemize}
    \item Model runtime and hardware accelerators (if available).
\end{itemize}

\subsubsection{Assumptions}
\begin{itemize}
    \item Input image includes at least some legible text.
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent \texttt{classifyScript(id)}:
\begin{itemize}
    \item output: \texttt{ScriptPrediction} containing predicted script label and confidence.
    \item exception: \texttt{ModelError} if classification fails or confidence undefined.
\end{itemize}

\subsubsection{Local Functions}
\begin{itemize}
    \item \texttt{preprocessForScript(img)} – applies script-specific preprocessing pipeline.
\end{itemize}



\section{MIS of ML.TextSim} \label{ML.TextSim}

\subsection{Module}
\textbf{ML.TextSim} \; (Textual Content Similarity Model)

This module computes semantic similarity between text segments derived from transcribed text or manual annotations.

\subsection{Uses}
\begin{itemize}
    \item \texttt{Data.FragmentStore} – for accessing fragment text content.
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}
\begin{itemize}
    \item \texttt{EMBEDDING\_DIM}
\end{itemize}

\subsubsection{Exported Access Programs}

\begin{table}[H]
\centering
\small
\caption{ML.TextSim - Exported Access Programs}
\begin{tabular}{p{3.8cm} p{4.5cm} p{2.5cm} p{3.2cm}}
\toprule
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\midrule
\texttt{embedText} & \texttt{text: String} & \texttt{TextEmbedding} & \texttt{ModelError} \\
\texttt{scoreTextSimilarity} & \texttt{a: TextEmbedding, b: TextEmbedding} & \texttt{float} & \texttt{ModelError} \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
    \item Embedding model weights.
\end{itemize}

\subsubsection{Environment Variables}
\begin{itemize}
    \item Model runtime.
\end{itemize}

\subsubsection{Assumptions}
\begin{itemize}
    \item Input text is normalized (script, encoding).
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent \texttt{embedText(text)}:
\begin{itemize}
    \item output: fixed-length embedding vector.
    \item exception: \texttt{ModelError} if model fails.
\end{itemize}

\noindent \texttt{scoreTextSimilarity(a, b)}:
\begin{itemize}
    \item output: similarity score in \([0, 1]\).
    \item exception: \texttt{ModelError} if inputs invalid.
\end{itemize}

\subsubsection{Local Functions}
\begin{itemize}
    \item \texttt{cosineSimilarity(a, b)} – core similarity computation.
\end{itemize}



\section{MIS of ML.Segmentation} \label{ML.Segmentation}

\subsection{Module}
\textbf{ML.Segmentation} \; (Fragment Segmentation Model)

This module performs image segmentation to identify and isolate individual fragment regions from manuscript images. It detects fragment boundaries and separates multiple fragments that may appear in a single scanned image.

\subsection{Uses}
\begin{itemize}
    \item \texttt{HW.ImageStorage} – for retrieving images to segment.
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}
\begin{itemize}
    \item \texttt{MIN\_FRAGMENT\_SIZE} – minimum area threshold for valid fragments.
    \item \texttt{SEGMENTATION\_CONFIDENCE\_THRESHOLD = 0.7}
\end{itemize}

\subsubsection{Exported Access Programs}

\begin{table}[H]
\centering
\small
\caption{ML.Segmentation - Exported Access Programs}
\begin{tabular}{p{3.5cm} p{3.5cm} p{3.5cm} p{3.5cm}}
\toprule
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\midrule
\texttt{segmentImage} & \texttt{id: ImageID} & \texttt{SegmentationResult} & \texttt{ModelError} \\
\texttt{extractFragments} & \texttt{id: ImageID, masks: SegmentMaskList} & \texttt{Sequence[ImageID]} & \texttt{ModelError} \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
    \item Segmentation model weights and configuration.
\end{itemize}

\subsubsection{Environment Variables}
\begin{itemize}
    \item Model runtime environment for deep learning inference.
\end{itemize}

\subsubsection{Assumptions}
\begin{itemize}
    \item Input images have been preprocessed (orientation correction, resolution normalization).
    \item Fragments in the image have sufficient contrast with the background.
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent \texttt{segmentImage(id)}:
\begin{itemize}
    \item output: \texttt{SegmentationResult} containing binary masks and bounding boxes for detected fragments.
    \item exception: \texttt{ModelError} if segmentation fails or image cannot be processed.
\end{itemize}

\noindent \texttt{extractFragments(id, masks)}:
\begin{itemize}
    \item transition: creates separate image files for each detected fragment region; stores them via \texttt{HW.ImageStorage}.
    \item output: sequence of new \texttt{ImageID} values for extracted fragments.
    \item exception: \texttt{ModelError} if extraction or storage fails.
\end{itemize}

\subsubsection{Local Functions}
\begin{itemize}
    \item \texttt{applyMorphology(mask)} – cleans segmentation masks using morphological operations.
    \item \texttt{filterSmallRegions(masks)} – removes regions below \texttt{MIN\_FRAGMENT\_SIZE}.
\end{itemize}



\section{MIS of ML.CircleRecognition} \label{ML.CircleRecognition}

\subsection{Module}
\textbf{ML.CircleRecognition} \; (Circle Detection and Recognition Model)

This module detects circular marks, holes, or decorative elements in manuscript fragments. These features can serve as additional matching criteria when aligning fragments.

\subsection{Uses}
\begin{itemize}
    \item \texttt{HW.ImageStorage} – for accessing fragment images.
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}
\begin{itemize}
    \item \texttt{MIN\_CIRCLE\_RADIUS} – minimum detectable circle size in pixels.
    \item \texttt{MAX\_CIRCLE\_RADIUS} – maximum detectable circle size in pixels.
\end{itemize}

\subsubsection{Exported Access Programs}

\begin{table}[H]
\centering
\small
\caption{ML.CircleRecognition - Exported Access Programs}
\begin{tabular}{p{3.5cm} p{3.5cm} p{3.5cm} p{3.5cm}}
\toprule
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\midrule
\texttt{detectCircles} & \texttt{id: ImageID} & \texttt{CircleList} & \texttt{ModelError} \\
\texttt{matchCirclePatterns} & \texttt{a: CircleList, b: CircleList} & \texttt{float} & \texttt{ModelError} \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
    \item Detection parameters and thresholds.
\end{itemize}

\subsubsection{Environment Variables}
\begin{itemize}
    \item Image processing library (e.g., OpenCV).
\end{itemize}

\subsubsection{Assumptions}
\begin{itemize}
    \item Circles are sufficiently distinct from background texture.
    \item Images are preprocessed and normalized.
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent \texttt{detectCircles(id)}:
\begin{itemize}
    \item output: \texttt{CircleList} containing center coordinates, radii, and confidence scores for detected circles.
    \item exception: \texttt{ModelError} if detection fails.
\end{itemize}

\noindent \texttt{matchCirclePatterns(a, b)}:
\begin{itemize}
    \item output: similarity score in \([0, 1]\) based on spatial arrangement and properties of circles.
    \item exception: \texttt{ModelError} if matching algorithm fails.
\end{itemize}

\subsubsection{Local Functions}
\begin{itemize}
    \item \texttt{computeSpatialHash(circles)} – creates geometric hash for circle arrangement.
    \item \texttt{filterOverlappingCircles(circles)} – removes duplicate detections.
\end{itemize}



\section{MIS of ML.LineCount} \label{ML.LineCount}

\subsection{Module}
\textbf{ML.LineCount} \; (Text Line Counting Model)

This module analyzes manuscript fragments to count the number of text lines present. Line count serves as a useful filtering and matching criterion during fragment search and reconstruction.

\subsection{Uses}
\begin{itemize}
    \item \texttt{HW.ImageStorage} – for accessing fragment images.
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}
\begin{itemize}
    \item \texttt{MIN\_LINE\_SPACING} – minimum expected spacing between lines in pixels.
\end{itemize}

\subsubsection{Exported Access Programs}

\begin{table}[H]
\centering
\small
\caption{ML.LineCount - Exported Access Programs}
\begin{tabular}{p{3.5cm} p{3.5cm} p{3.5cm} p{3.5cm}}
\toprule
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\midrule
\texttt{countLines} & \texttt{id: ImageID} & \texttt{LineCountResult} & \texttt{ModelError} \\
\texttt{detectLineRegions} & \texttt{id: ImageID} & \texttt{Sequence[BoundingBox]} & \texttt{ModelError} \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
    \item Line detection model parameters.
\end{itemize}

\subsubsection{Environment Variables}
\begin{itemize}
    \item Image processing and model inference environment.
\end{itemize}

\subsubsection{Assumptions}
\begin{itemize}
    \item Text lines are approximately horizontal after preprocessing.
    \item Sufficient contrast exists between text and background.
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent \texttt{countLines(id)}:
\begin{itemize}
    \item output: \texttt{LineCountResult} containing the number of detected lines and confidence score.
    \item exception: \texttt{ModelError} if counting fails or image quality insufficient.
\end{itemize}

\noindent \texttt{detectLineRegions(id)}:
\begin{itemize}
    \item output: sequence of \texttt{BoundingBox} objects defining the spatial extent of each text line.
    \item exception: \texttt{ModelError} if line detection fails.
\end{itemize}

\subsubsection{Local Functions}
\begin{itemize}
    \item \texttt{projectHorizontally(img)} – creates horizontal projection histogram for line detection.
    \item \texttt{findLineBoundaries(projection)} – identifies line separation points in projection.
\end{itemize}



\section{MIS of ML.EdgeClassification} \label{ML.EdgeClassification}

\subsection{Module}
\textbf{ML.EdgeClassification} \; (Edge Type Classification Model)

This module classifies fragment edges into categories such as torn, cut, original (manuscript boundary), or burned. Edge type classification helps improve matching accuracy by ensuring compatible edge pairs are compared.

\subsection{Uses}
\begin{itemize}
    \item \texttt{HW.ImageStorage} – for accessing fragment images.
    \item \texttt{ML.EdgeMatch} – edge signatures may be shared for classification.
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}
\begin{itemize}
    \item \texttt{EDGE\_TYPES = \\{torn, cut, original, burned, unknown\\}}
    \item \texttt{MIN\_CLASSIFICATION\_CONFIDENCE = 0.6}
\end{itemize}

\subsubsection{Exported Access Programs}

\begin{table}[H]
\centering
\small
\caption{ML.EdgeClassification - Exported Access Programs}
\begin{tabular}{p{3.5cm} p{3.5cm} p{3.5cm} p{3.5cm}}
\toprule
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\midrule
\texttt{classifyEdges} & \texttt{id: ImageID} & \texttt{EdgeClassificationResult} & \texttt{ModelError} \\
\texttt{getEdgeType} & \texttt{id: ImageID, edge: EdgeRegion} & \texttt{EdgeTypePrediction} & \texttt{ModelError} \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
    \item Edge classification model weights.
\end{itemize}

\subsubsection{Environment Variables}
\begin{itemize}
    \item Model runtime for deep learning inference.
\end{itemize}

\subsubsection{Assumptions}
\begin{itemize}
    \item Fragment edges are clearly visible in preprocessed images.
    \item Training data covers representative examples of each edge type.
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent \texttt{classifyEdges(id)}:
\begin{itemize}
    \item output: \texttt{EdgeClassificationResult} containing edge type predictions for all detected edges with confidence scores.
    \item exception: \texttt{ModelError} if classification fails.
\end{itemize}

\noindent \texttt{getEdgeType(id, edge)}:
\begin{itemize}
    \item output: \texttt{EdgeTypePrediction} for a specific edge region containing predicted type and confidence.
    \item exception: \texttt{ModelError} if edge region invalid or classification fails.
\end{itemize}

\subsubsection{Local Functions}
\begin{itemize}
    \item \texttt{extractEdgeFeatures(img, region)} – computes texture and shape features for edge region.
    \item \texttt{normalizeConfidences(predictions)} – adjusts confidence scores to sum to 1.0.
\end{itemize}



%===========================
% UTILITY / SUPPORT MODULES
%===========================

\section{MIS of Util.Error} \label{Util.Error}

\subsection{Module}
\textbf{Util.Error} \; (Error Type and Exception Utilities)

This module defines standard error types and helpers for constructing and handling errors in a consistent way across modules.

\subsection{Uses}
\begin{itemize}
    \item None at the architectural level; referenced by many other modules.
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}
\begin{itemize}
    \item Standard error codes or identifiers (for example, \texttt{ERR\_NOT\_FOUND}, \texttt{ERR\_VALIDATION}).
\end{itemize}

\subsubsection{Exported Access Programs}

\begin{table}[H]
\centering
\small
\caption{Util.Error - Exported Access Programs}
\begin{tabular}{p{3.5cm} p{4cm} p{3cm} p{3.5cm}}
\toprule
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\midrule
\texttt{buildError} & \texttt{code: String, msg: String} & \texttt{ErrorObject} & \texttt{None} \\
\texttt{toClientMessage} & \texttt{err: ErrorObject} & \texttt{String} & \texttt{None} \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
    \item None.
\end{itemize}

\subsubsection{Environment Variables}
\begin{itemize}
    \item None.
\end{itemize}

\subsubsection{Assumptions}
\begin{itemize}
    \item All modules reference the same canonical error types.
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent \texttt{buildError(code, msg)}:
\begin{itemize}
    \item output: structured error object capturing code and message.
    \item exception: none.
\end{itemize}

\noindent \texttt{toClientMessage(err)}:
\begin{itemize}
    \item output: safe message for display at UI or API boundary.
    \item exception: none.
\end{itemize}



\section{MIS of Util.Logging} \label{Util.Logging}

\subsection{Module}
\textbf{Util.Logging} \; (Logging Utility)

This module provides structured logging for events, errors, and performance metrics.

\subsection{Uses}
\begin{itemize}
    \item Underlying logging framework or standard output.
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}
\begin{itemize}
    \item Log levels such as \texttt{INFO}, \texttt{WARN}, \texttt{ERROR}.
\end{itemize}

\subsubsection{Exported Access Programs}

\begin{table}[H]
\centering
\small
\caption{Util.Logging - Exported Access Programs}
\begin{tabular}{p{3.5cm} p{3.5cm} p{3.5cm} p{3.5cm}}
\toprule
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\midrule
\texttt{logInfo} & \texttt{msg: String} & \texttt{none} & \texttt{None} \\
\texttt{logWarn} & \texttt{msg: String} & \texttt{none} & \texttt{None} \\
\texttt{logError} & \texttt{msg: String, err: ErrorObject} & \texttt{none} & \texttt{None} \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
    \item Optional runtime configuration (log level, sinks).
\end{itemize}

\subsubsection{Environment Variables}
\begin{itemize}
    \item File system, console, or external logging service.
\end{itemize}

\subsubsection{Assumptions}
\begin{itemize}
    \item Logging operations are non-fatal and do not throw.
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent \texttt{logInfo(msg)}:
\begin{itemize}
    \item output: none; writes informational log entry.
    \item exception: none.
\end{itemize}

\noindent \texttt{logWarn(msg)}:
\begin{itemize}
    \item output: none; writes warning log entry.
    \item exception: none.
\end{itemize}

\noindent \texttt{logError(msg, err)}:
\begin{itemize}
    \item output: none; writes error entry including details from \texttt{err}.
    \item exception: none.
\end{itemize}



\section{MIS of Util.Config} \label{Util.Config}

\subsection{Module}
\textbf{Util.Config} \; (Configuration Management)

This module provides read-only access to configuration values such as database connection strings, model paths, and feature flags.

\subsection{Uses}
\begin{itemize}
    \item Environment variables or configuration files.
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}
\begin{itemize}
    \item None fixed; keys are used to look up values.
\end{itemize}

\subsubsection{Exported Access Programs}

\begin{table}[H]
\centering
\small
\caption{Util.Config - Exported Access Programs}
\begin{tabular}{p{3.5cm} p{3.5cm} p{3.5cm} p{3.5cm}}
\toprule
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\midrule
\texttt{getValue} & \texttt{key: String} & \texttt{String} & \texttt{ConfigError} \\
\texttt{getBool} & \texttt{key: String} & \texttt{bool} & \texttt{ConfigError} \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
    \item \texttt{configCache: Map[String, String]}
\end{itemize}

\subsubsection{Environment Variables}
\begin{itemize}
    \item Config file or environment variable store.
\end{itemize}

\subsubsection{Assumptions}
\begin{itemize}
    \item Configuration is loaded at startup and remains static during runtime.
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent \texttt{getValue(key)}:
\begin{itemize}
    \item output: configuration value associated with \texttt{key}.
    \item exception: \texttt{ConfigError} if key missing.
\end{itemize}

\noindent \texttt{getBool(key)}:
\begin{itemize}
    \item output: parsed boolean value.
    \item exception: \texttt{ConfigError} if key missing or value not parseable.
\end{itemize}



\section{MIS of Util.TestStub} \label{Util.TestStub}

\subsection{Module}
\textbf{Util.TestStub} \; (Testing Stubs and Fakes)

This module provides stub implementations of selected services and ML components for use in automated tests.

\subsection{Uses}
\begin{itemize}
    \item Core service and ML interfaces for type compatibility.
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}
\begin{itemize}
    \item None.
\end{itemize}

\subsubsection{Exported Access Programs}

\begin{table}[H]
\centering
\small
\caption{Util.TestStub - Exported Access Programs}
\begin{tabular}{p{3.8cm} p{2.5cm} p{4.2cm} p{3.5cm}}
\toprule
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\midrule
\texttt{getFixedOCRStub} & \texttt{none} & \texttt{ML.OCR-like object} & \texttt{None} \\
\texttt{getFixedMatchStub} & \texttt{none} & \texttt{Svc.MatchOrch-like object} & \texttt{None} \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
    \item Predefined responses used for deterministic tests.
\end{itemize}

\subsubsection{Environment Variables}
\begin{itemize}
    \item None.
\end{itemize}

\subsubsection{Assumptions}
\begin{itemize}
    \item Stubs are only used in test environments.
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent \texttt{getFixedOCRStub()}:
\begin{itemize}
    \item output: object implementing \texttt{runOCR} that returns predictable results for known inputs.
    \item exception: none.
\end{itemize}

\noindent \texttt{getFixedMatchStub()}:
\begin{itemize}
    \item output: object implementing \texttt{generateMatches} with fixed candidate lists.
    \item exception: none.
\end{itemize}

\subsubsection{Local Functions}
\begin{itemize}
    \item \texttt{loadStubFixtures()} – loads predefined responses from static files.
\end{itemize}

\newpage

\bibliographystyle {plainnat}
\bibliography {../../../refs/References}

\newpage



\section*{Appendix --- Reflection}

The information in this section will be used to evaluate the team members on the
graduate attribute of Problem Analysis and Design.


\begin{enumerate}
  \item What went well while writing this deliverable? 
  
    \hspace{2em} One aspect that went particularly well was identifying the appropriate notation and determining which modules needed to be included in the design. Our team communicated effectively throughout this process, which helped us maintain a shared understanding of the system and its structure. Because we already had a strong grasp of the project vision, it was relatively easy to map our ideas into a formal design representation. As a result, we were able to present a clear and coherent picture of the system architecture that reflects both the requirements and the intended functionality.

  \item What pain points did you experience during this deliverable, and how
    did you resolve them?

    \hspace{2em} The main challenge we encountered was thinking through the lower-level implementation details. At this stage, we have not yet progressed far into the actual coding, so some of the design decisions, especially those related to specific algorithms, data structures, and system interactions required educated assumptions rather than concrete experience. We addressed this by focusing on higher-level abstractions and deferring detailed implementation decisions until we gain more clarity during development. This allowed us to complete the deliverable while still leaving room for necessary adjustments later.

  \item Which of your design decisions stemmed from speaking to your client(s)
  or a proxy (e.g. your peers, stakeholders, potential users)? For those that
  were not, why, and where did they come from?

    \hspace{2em} Many of our design decisions, especially those involving the user interface, were directly influenced by conversations with our supervisor, Dr. Shayne. Since he does not come from a technical background, he primarily expressed his needs in terms of how he wanted to interact with the system. This naturally shaped the UI and the workflow we designed for scholars. Additionally, the inclusion of segmentation-based machine learning came from his explicit request; he emphasized that automated assistance in identifying and matching fragments would significantly improve his research workflow. These inputs helped anchor our design choices in real user needs.

  \item While creating the design doc, what parts of your other documents (e.g.
  requirements, hazard analysis, etc), it any, needed to be changed, and why?

    \hspace{2em} Very few changes were needed to our previous documents. Because this is a pre-approved project with a well-defined problem and scope, many of the requirements and expectations were already laid out for us in the project description. As a result, our earlier documents, such as the SRS \citep{SRS-Sanskrit-Ciphers} and Hazard Analysis \citep{HazardAnalysis}, aligned naturally with the design work we did here. We did not need to revisit or adjust them significantly, beyond minor wording refinements and consistency updates.

  \item What are the limitations of your solution?  Put another way, given
  unlimited resources, what could you do to make the project better? (LO\_ProbSolutions)

    \hspace{2em} With unlimited resources, one of the most impactful improvements would be investing in more powerful AI infrastructure, such as GPUs dedicated to training and evaluating models. This would allow us to train new segmentation or matching models more frequently and at a much larger scale. We would also aim to build a more advanced fragment-matching pipeline with higher accuracy and more robust behaviour across different manuscript types. Additionally, we would elevate the quality of the UI significantly, improving performance, adding more interactive tools, and making the interface cleaner and more intuitive. Overall, the entire system could operate at a higher level of precision, speed, and sophistication.

  \item Give a brief overview of other design solutions you considered.  What
  are the benefits and tradeoffs of those other designs compared with the chosen
  design?  From all the potential options, why did you select the documented design?
  (LO\_Explores)

    \hspace{2em} We did not explore many alternative designs because, from early discussions, the entire team already shared a clear mental model of how the system should operate. Our frequent conversations kept us aligned on the major components and workflow, so we naturally converged on a single coherent design. Although this meant we did not formally evaluate multiple competing solutions, the advantage was that we were able to focus our efforts on developing one strong, detailed design rather than splitting time considering options that did not align with the client’s expectations. Given the clarity of the problem and the constraints provided, the chosen design was the most straightforward and appropriate path forward.

\end{enumerate}


\end{document}